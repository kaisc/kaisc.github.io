<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://markindev.github.io/"/>
  <updated>2016-02-15T16:16:47.000Z</updated>
  <id>http://markindev.github.io/</id>
  
  <author>
    <name>Jingkai Mao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust in Details Part 1</title>
    <link href="http://markindev.github.io/2016/02/15/Rust-in-Details-Part-1/"/>
    <id>http://markindev.github.io/2016/02/15/Rust-in-Details-Part-1/</id>
    <published>2016-02-15T11:58:04.000Z</published>
    <updated>2016-02-15T16:16:47.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;此篇文章翻译自&lt;a href=&quot;&quot;&gt;Rust-In-Details&lt;/a&gt;，已获得作者许可。转载或二次创作请保留本信息。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Part-1-实现Websocket协议&quot;&gt;&lt;a href=&quot;#Part-1-实现Websocket协议&quot; class=&quot;headerlink&quot; title=&quot;Part 1: 实现Websocket协议.&quot;&gt;&lt;/a&gt;Part 1: 实现Websocket协议.&lt;/h2&gt;&lt;p&gt;我们将会用一系列的文章，一步一步的来详细介绍如何编写一个可扩展、实时的聊天服务。&lt;/p&gt;
&lt;p&gt;为了更好的了解如何使用Rust来解决一些实际问题，我们将在本系列文章中，逐步的尝试使用Rust来编写一个可扩展的、实时的聊天服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Part 1&lt;/em&gt;包含了一些基本的项目配置，和一个简单的Websocket服务器框架。这些文章相当的深入浅出，并不需要读者有太多关于Rust的背景知识。当然，如果你熟悉POSIX API或者是C/C++，那么肯定会极大的有助于深入理解。最后，这是一篇相当长、而且面向底层的教程，我推荐你先准备上一杯好咖啡。&lt;/p&gt;
&lt;p&gt;好了，让我们开始吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Table-of-Contents&quot;&gt;&lt;a href=&quot;#Table-of-Contents&quot; class=&quot;headerlink&quot; title=&quot;Table of Contents&quot;&gt;&lt;/a&gt;Table of Contents&lt;/h2&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#why-rust&quot;&gt;为什么是Rust?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#goals&quot;&gt;目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#approaches-to-io&quot;&gt;关于I/O的初步考量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#event-loop&quot;&gt;事件循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#starting-project&quot;&gt;初始化工程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#event-loop-in-rust&quot;&gt;Rust中的事件循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tcp-server&quot;&gt;TCP服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#accepting-connections&quot;&gt;接受连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#parsing-http&quot;&gt;Parsing HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#handshake&quot;&gt;Handshake&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#resources&quot;&gt;Resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#notes&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-为什么是Rust&quot;&gt;&lt;a href=&quot;#1-为什么是Rust&quot; class=&quot;headerlink&quot; title=&quot;1 为什么是Rust?&quot;&gt;&lt;/a&gt;1 为什么是Rust?&lt;/h2&gt;&lt;p&gt;出于对系统编程的兴趣，我开始留意到Rust这门新生语言。底层开发总是带给我各式各样的挑战和满足，在这个领域有一个很常见的共识，那就是：由于众多不起眼的陷阱，正确的做对一件事情往往是非常困难的。&lt;/p&gt;
&lt;img src=&quot;/2016/02/15/Rust-in-Details-Part-1/rust-logo.png&quot; alt=&quot;rust-logo&quot; title=&quot;rust-logo&quot;&gt;
&lt;p&gt;最常见的陷阱莫过于内存安全。它可能导致一系列诸如&lt;a href=&quot;https://en.wikipedia.org/wiki/Buffer_overflow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;缓存溢出&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_leak&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存泄露&lt;/a&gt;、&lt;a href=&quot;http://stackoverflow.com/questions/21057393/what-does-double-free-mean&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Double Free&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Dangling_pointer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;野指针&lt;/a&gt;等让人头疼的问题。一个较为有名的例子便是OpenSSL中出现的&lt;a href=&quot;http://heartbleed.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Headerbleed&lt;/a&gt; Bug，它就是由于不恰当的内存管理而导致的。出于同样的陷阱，也许还有更多更严重的Bug存在于这些软件之中也并不让人奇怪。&lt;/p&gt;
&lt;p&gt;当然，在C++中我们有不少的工具和法则诸如智能指针[&lt;a href=&quot;#ref-1&quot;&gt;1&lt;/a&gt;]、On-Stack Allocation[&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;]等来试图解决问题。但遗憾的是，这些处理方式并不是建立在语言层面的。为了获得正确的行为，它假设所有的相关开发者，都能够正确理解并坚决的执行统一的设计。当代码库越来越庞大，参与人员越来越多，为了在庞大的Codebase中检查和避免错误，无论是对于开发人员的个人素质还是团队管理，都提出了不小的挑战。如果这些棘手而机械的问题可以被机器恰当的处理，那简直是再好不过了。&lt;/p&gt;
&lt;p&gt;这就是垃圾回收（Garbage Collection）的产生的主要背景和原因。作为目前最热门的自动内存管理机制，几乎所有现在的语言及虚拟机都在某种程度上面使用了垃圾回收，它很好的解决了上面所说的内存问题。当然它也有自己的不足之处：在某些情况下，它过分的复杂了[&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;]。它使用一个额外的运行时系统来标记、收集、清理未使用的内存[&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;]，对于某些高性能要求的程序来说，往往需要付出相当的努力来优化GC导致的性能影响。&lt;/p&gt;
&lt;p&gt;Rust，我们的主角，使用&lt;em&gt;&lt;a href=&quot;http://doc.rust-lang.org/stable/book/ownership.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ownership&lt;/a&gt;&lt;/em&gt;和&lt;em&gt;borrowing&lt;/em&gt;这两个概念来完成自动内存管理。它在确保内存安全的同时，可以避免额外的性能开销。&lt;/p&gt;
&lt;p&gt;在Rust中，我们假设任意一个值都只存在一个&lt;em&gt;owner&lt;/em&gt;。这意味着对某一特定的内存区域，同一时刻只存在一个可写的变量指向它。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; foo = &lt;span class=&quot;built_in&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 我们创建了一个具有元素1，2，3的向量A，并将它的所有权交由一个局部变量`foo`。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bar = foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 现在我们将向量A的所有权交由bar。至此，`foo`将无法再次访问。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于在任意一个地方，只有一个有效的值绑定存在。那么当绑定离开作用域（被&lt;code&gt;{&lt;/code&gt;和&lt;code&gt;}&lt;/code&gt;所包含的区域），所拥有的资源（内存，文件句柄，网络句柄等）便可以自动的被释放掉。虽然听上去可能有些复杂，但不难发现，这个手段其实是非常常见且有效的方法。它有些类似于C++中的&lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;组件，但却是通过编译时检查来完成的，并没有&lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;的额外消耗。这也就是Rust的杀手特性，使它既拥有现代语言安全的内存，也保留了C/C++类语言的效率。&lt;/p&gt;
&lt;h2 id=&quot;2-目标&quot;&gt;&lt;a href=&quot;#2-目标&quot; class=&quot;headerlink&quot; title=&quot;2 目标&quot;&gt;&lt;/a&gt;2 目标&lt;/h2&gt;&lt;p&gt;我喜欢通过做一些简单的、生产场景的小项目来学习一个新的语言，这样可以在使用时了解语言特性的作用。现在我选择编写一个类似于Chat Roulette的匿名文本聊天服务来学习Rust，这是由于聊天服务往往需要在处理多个连接的同时快速做出响应，它不仅能用上不少的Rust特性，还能被用做测试对比Rust的实际性能和内存印迹。&lt;/p&gt;
&lt;p&gt;这系列文章的最终目标将是产生一个可执行文件以及一系列部署脚本，并将它们成功的部署运行在一些云服务器上面。&lt;/p&gt;
&lt;p&gt;开始动手写代码之前，我们先稍微花上一些时间来分析在线服务中相当重要的一个议题：I/O操作。&lt;/p&gt;
&lt;h2 id=&quot;3-关于I-O的初步考量&quot;&gt;&lt;a href=&quot;#3-关于I-O的初步考量&quot; class=&quot;headerlink&quot; title=&quot;3 关于I/O的初步考量&quot;&gt;&lt;/a&gt;3 关于I/O的初步考量&lt;/h2&gt;&lt;p&gt;为了正常的运转，我们的服务需要通过网络Sockets发送和接受数据。这听上去也许是一个简单的任务，但为了更加有效率的处理输入和输出操作，我们往往需要根据实际情况采用不同的方式，这些方式最主要的区别在于是否阻塞。在默认情况下，当我们等待数据到达或传递时，会进入阻塞状态并阻止其余所有的CPU操作。&lt;/p&gt;
&lt;p&gt;为了同时服务多个用户，避免某个I\O操作阻塞所有的用户请求，我们需要通过某种方式来独立他们。&lt;/p&gt;
&lt;p&gt;最常见的解决方式是为每一个用户创建一个独立的进程，那么阻塞就只能对当前上下文的单个进程造成影响。这种方式简单易于编写，但是会带来额外的性能开销。除了每个进程都需要的额外栈空间[&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;]外，每次发生进程&lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;上下文切换&lt;/em&gt;&lt;/a&gt;时都会产生额外的性能开销。现代服务器CPU往往都有8~16个核心，当进程变多时，相当多的时钟都被OS Kernel所占用以保证正确的进行调度行为，更不要说切换中所导致的缓存失效、内存换页等问题。这些开销往往超乎你的想象，你很难通过这种方式编写一个类似于TechCrush、HackerNews或者是Reddit那样拥有超高并发量、超酷的应用。&lt;/p&gt;
&lt;h2 id=&quot;4-事件循环&quot;&gt;&lt;a href=&quot;#4-事件循环&quot; class=&quot;headerlink&quot; title=&quot;4 事件循环&quot;&gt;&lt;/a&gt;4 事件循环&lt;/h2&gt;&lt;img src=&quot;/2016/02/15/Rust-in-Details-Part-1/io-multiplex.png&quot; alt=&quot;io-multiplex&quot; title=&quot;io-multiplex&quot;&gt;
&lt;p&gt;出于以上的原因，我们需要一些基于事件循环（Event Loop）的，更加高效的I/O多路复用API。在Linux[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]下面可以使用&lt;em&gt;epoll&lt;/em&gt;，在FreeBSD或者OS X[&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]下面可以使用&lt;em&gt;kqueuq&lt;/em&gt;。这些API基于一种类似的方法工作：在字节流首先从网络到达Sockets时，我们设置&lt;/p&gt;
&lt;p&gt;These different APIs work similarly in a straightforward way: bytes are coming over the network, arriving at the sockets, and instead of waiting when the data becomes available for a read, we’re &lt;em&gt;telling a socket to notify us&lt;/em&gt; when new data arrives.&lt;/p&gt;
&lt;p&gt;Notifications come in a form of events that end up in the event loop. And that’s where the blocking happens in this case: instead of periodic checks for thousands of sockets, we’re just waiting for new events to arrive. That’s an important distinction because particularly in WebSocket applications it’s very common to have many idle clients just waiting for some activity. With asynchronous I/O we’ll have a very little overhead of a socket handle and hundreds of bytes at most for an each client.&lt;/p&gt;
&lt;p&gt;Interestingly enough, it works great not only for network communications but for disk I/O as well, as the event loop accepts all kinds of file handles (and sockets in the *nix world are just file handles too).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.js event loop and Ruby’s EventMachine work the same way. The same goes for the nginx webserver which is built using async I/O[&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5-初始化工程&quot;&gt;&lt;a href=&quot;#5-初始化工程&quot; class=&quot;headerlink&quot; title=&quot;5 初始化工程&quot;&gt;&lt;/a&gt;5 初始化工程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我会假设你已经安装了Rust，假如你还没有完成这一步的话，请依据&lt;a href=&quot;https://doc.rust-lang.org/book/installing-rust.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;进行操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rust有一套类似于Maven/Composer/npm/rake的发布工具&lt;code&gt;cargo&lt;/code&gt;。它用于管理库依赖、处理构建过程、运行测试组件、简化工程创建等。让我们打开terminal，并执行下面的操作：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cargo new chat --bin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;--bin&lt;/code&gt;是用来告诉Cargo创建一个可执行程序项目而不是一个库项目。作为这段操作的结果，我们获得了两个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cargo.toml&lt;/li&gt;
&lt;li&gt;src/main.rs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Cargo.toml&lt;/code&gt;包含了项目信息和依赖量的描述（类似于JavaScript的&lt;code&gt;package.json&lt;/code&gt;）。而&lt;code&gt;src/main.rs&lt;/code&gt;则是我们工程的入口源文件。&lt;/p&gt;
&lt;p&gt;现在我们就可以通过命令&lt;code&gt;cargo run&lt;/code&gt;来编译、执行程序了。当然它也会提示相关的错误信息，如果我们确实犯了错的话。&lt;/p&gt;
&lt;h2 id=&quot;6-Rust中的事件循环&quot;&gt;&lt;a href=&quot;#6-Rust中的事件循环&quot; class=&quot;headerlink&quot; title=&quot;6 Rust中的事件循环&quot;&gt;&lt;/a&gt;6 Rust中的事件循环&lt;/h2&gt;&lt;p&gt;是时候用实践来检验理论了，让我们来创建一个简单的事件循环，它将会用于等待新的事件发生。幸运的是，我们并不需要手动处理所有的底层系统调用，有一个Rust库&lt;a href=&quot;https://github.com/carllerche/mio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;Metal IO&lt;/em&gt;&lt;/a&gt;(简称&lt;em&gt;mio&lt;/em&gt;)已经帮我们做了这些事情。&lt;/p&gt;
&lt;p&gt;如果你还记得的话，我们使用Cargo来进行依赖库文件管理。它默认从Rust的包仓库&lt;a href=&quot;https://crates.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;cargo.io&lt;/em&gt;&lt;/a&gt;下载所需要的库文件。如果你需要使用某个最新的功能时，当然也可以通过配置直接从其他的Git仓库获取最新版本。&lt;/p&gt;
&lt;p&gt;在完成这个系列文章的时候，cargo.io只存在&lt;code&gt;mio&lt;/code&gt;的0.4版本。由于较新的v0.5版本引入了更多的功能和一些不兼容的API调整，所以我们选择配置&lt;code&gt;Cargo.toml&lt;/code&gt;，并使用最新的版本。&lt;/p&gt;
&lt;figure class=&quot;highlight toml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;[dependencies]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;setting&quot;&gt;mio = &lt;span class=&quot;value&quot;&gt;&amp;#123; git = &lt;span class=&quot;string&quot;&gt;&quot;https://github.com/carllerche/mio&quot;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在我们添加完依赖后，我们需要在代码中显式的导入它们。所以让我们打开&lt;code&gt;main.rs&lt;/code&gt;，并编辑：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;crate&lt;/span&gt; mio;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; mio::*;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;mio&lt;/code&gt;的使用相当简单。首先，我们通过调用&lt;code&gt;EventLoop::new()&lt;/code&gt;来创建一个事件循环，当然，仅仅有一个事件循环对象并没有太大的用处。我们需要定义一个实现了&lt;code&gt;Handler&lt;/code&gt;接口的&lt;a href=&quot;http://doc.rust-lang.org/stable/book/structs.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;structure&lt;/em&gt;&lt;/a&gt;来驱动它。&lt;/p&gt;
&lt;p&gt;Though Rust doesn’t support object-oriented programming in a “traditional” way, structures (or &lt;em&gt;structs&lt;/em&gt;) are analogous in many ways to classes from the classic OOP, and they can implement interfaces that are enforced by a special language construct called &lt;a href=&quot;http://doc.rust-lang.org/stable/book/traits.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;traits&lt;/em&gt;&lt;/a&gt;.&lt;br&gt;尽管Rust”常见”的方式支持面向对象范式（OOP），&lt;/p&gt;
&lt;p&gt;这是我们定义一个struct的方式：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; WebSocketServer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为结构WebSocketServer实现&lt;a href=&quot;https://carllerche.github.io/mio/mio/trait.Handler.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Handler&lt;/a&gt; Trait&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;impl&lt;/span&gt; Handler &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; WebSocketServer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Traits可以拥有默认的实现，所以Handler只需要我们提供具体的timeout和message类型；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 我们不会在这里涉及过多的细节，所以就让我们直接使用mio实例中的实现好了。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Timeout&lt;/span&gt; = usize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Message&lt;/span&gt; = ();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动事件循环：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut&lt;/span&gt; event_loop = EventLoop::new().unwrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建一个WebSocketServer实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut&lt;/span&gt; handler = WebSocketServer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... 将它以可变引用的方式传入事件循环中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    event_loop.run(&amp;amp;&lt;span class=&quot;keyword&quot;&gt;mut&lt;/span&gt; handler).unwrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们终于第一次接触到了&lt;em&gt;borrows&lt;/em&gt;，注意最后一行中&lt;code&gt;&amp;amp;mut&lt;/code&gt;的使用。它意味着我们临时的将所有权转移到了另外的绑定中，并且这个绑定是&lt;em&gt;可变的&lt;/em&gt;。&lt;/p&gt;
&lt;img src=&quot;/2016/02/15/Rust-in-Details-Part-1/mut-borrow.png&quot; alt=&quot;mut-borrow&quot; title=&quot;mut-borrow&quot;&gt;
&lt;p&gt;为了简单起见，我们可以使用下面两端伪代码来理解borrowing：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将value绑定至owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; owner = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建一个新的作用域，并将所有权转移至borrow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; borrow = owner;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 现在borrow可以读写值了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    borrow.mutate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将所有权返还给owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    owner = borrow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码差不多等价于：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将value绑定至owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; owner = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将value的所有权暂时可写的转借给borrow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut&lt;/span&gt; borrow = &amp;amp;&lt;span class=&quot;keyword&quot;&gt;mut&lt;/span&gt; owner;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    borrow.mutate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 当borrow离开作用域时，将被转借的所有权自动归还给owner&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;em&gt;每个作用域&lt;/em&gt;，只能存在一个&lt;em&gt;mutable borrow&lt;/em&gt;。实际上，当值的所有权被转借出去之后，在所有权被归还之前，原来持有该值的&lt;code&gt;owner&lt;/code&gt;也不能读写该值。&lt;/p&gt;
&lt;p&gt;我们还有一种&lt;em&gt;immutable borrowing&lt;/em&gt;的方式，它允许我们只读的访问指向的变量。与&lt;code&gt;&amp;amp;mut borrow&lt;/code&gt;不同，它允许我们对同一个变量持有多个只读的绑定，但它隐含了一些特殊规则，如果当前作用域内存在&lt;em&gt;immutable borrowing&lt;/em&gt;，那么我们既不可以改变变量也不可以以&lt;em&gt;mutable&lt;/em&gt;的形式将该变量borrow出去。&lt;/p&gt;
&lt;p&gt;如果这个解释不够清晰，请原谅我并稍微耐下心。来由于borrows遍布于Rust的代码当中，所以我们有更多的机会在实际的代码中理解它。现在让我们回到工程本身。&lt;/p&gt;
&lt;p&gt;通过运行&lt;code&gt;cargo run&lt;/code&gt;，Cargo会自动下载所有需要的依赖，并编译、运行我们的工程。&lt;/p&gt;
&lt;p&gt;似乎让人有些失望，运行的结果只是在terminal中一个闪烁的光标指针。但那意味我们已经成功的将事件循环运行起来了，现在让我们来给他添加一些实际的用处。&lt;/p&gt;
&lt;h2 id=&quot;7-TCP服务器&quot;&gt;&lt;a href=&quot;#7-TCP服务器&quot; class=&quot;headerlink&quot; title=&quot;7 TCP服务器&quot;&gt;&lt;/a&gt;7 TCP服务器&lt;/h2&gt;&lt;p&gt;为了创建一个TCP Server来接收WebSocket连接，我们需要使用空间&lt;code&gt;mio::tcp&lt;/code&gt;中一个特殊的结构&lt;code&gt;TcpListener&lt;/code&gt;。并且依据标准的流程创建一个服务器端Tcp Socket：绑定地址、监听、接收连接。下面是相关代码：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; std::net::SocketAddr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; mio::tcp::*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; address = &lt;span class=&quot;string&quot;&gt;&quot;0.0.0.0:10000&quot;&lt;/span&gt;.parse::&amp;lt;SocketAddr&amp;gt;().unwrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; server_socket = TcpListener::bind(&amp;amp;address).unwrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;event_loop.register(&amp;amp;server_socket,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Token(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    EventSet::readable(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    PollOpt::edge()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在让我们一行一行的分析上面的代码：&lt;/p&gt;
&lt;p&gt;首先我们需要将TCP相关的空间和套接字结构导入到&lt;code&gt;main.rs&lt;/code&gt;文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; mio::tcp::*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt; std::net::SocketAddr;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们把字符串&lt;code&gt;&amp;quot;0.0.0.0:10000&amp;quot;&lt;/code&gt;解析为地址的结构体，并使用&lt;code&gt;TcpListener&lt;/code&gt;来启动套接字监听：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; address = &lt;span class=&quot;string&quot;&gt;&quot;0.0.0.0:10000&quot;&lt;/span&gt;.parse::&amp;lt;SocketAddr&amp;gt;().unwrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; server_socket = TcpListener::bind(&amp;amp;address).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也许你会注意到每一行的最后我们都调用了&lt;code&gt;unwrap&lt;/code&gt;，请先暂时忽略它。现在我们需要把生成的套接字注册进事件循环中：&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event_loop.register(&amp;amp;server_socket,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        Token(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        EventSet::readable(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        PollOpt::edge()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;register&lt;/code&gt;的参数稍微有些复杂：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Token&lt;/em&gt; 是我们传入套接字的一个全局唯一标示符。当我们收到新事件时，我们可以通过这个标示符来确定事件是从哪个套接字产生的。这里我们简单使用&lt;code&gt;Token(0)&lt;/code&gt;作为监听套接字的标示符。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;EventSet&lt;/em&gt; 指明了我们所监听消息的类型：是收到新数据时触发事件，还是发送数据时触发事件，异或是两者都有？&lt;/li&gt;
&lt;li&gt;&lt;em&gt;PollOpt&lt;/em&gt; 指明我触发的类型：&lt;code&gt;PollOpt::edge()&lt;/code&gt;表示我们想要采用&lt;em&gt;边缘触发&lt;/em&gt;而不是&lt;em&gt;水平触发&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只要对应套接字中有数据可读写时，水平触发即产生新的事件，而边缘触发只在有新数据到达套接字时才会触发事件。你可以参考&lt;a href=&quot;http://stackoverflow.com/questions/1966863/level-vs-edge-trigger-network-event-mechanisms&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow&lt;/a&gt;上面的这篇回答获得更多的细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，假如我们通过&lt;code&gt;cargo run&lt;/code&gt;运行当前的程序，并使用&lt;code&gt;lsof&lt;/code&gt;命令，就可以看到如下的输出：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lsof -i :&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;COMMAND   PID        USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chat    &lt;span class=&quot;number&quot;&gt;58490&lt;/span&gt; &amp;lt;your user&amp;gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;u   IPv4 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;x333c1924c045ccc7      &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;t0  TCP *:ndmp (LISTEN)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;8-接受连接&quot;&gt;&lt;a href=&quot;#8-接受连接&quot; class=&quot;headerlink&quot; title=&quot;8 接受连接&quot;&gt;&lt;/a&gt;8 接受连接&lt;/h2&gt;&lt;p&gt;All WebSocket connections start with a &lt;em&gt;handshake&lt;/em&gt; &amp;mdash; a special sequence of HTTP requests and responses to negotiate the protocol. Hence, we need to teach the server to talk HTTP/1.1 to successfully implement WebSocket. &lt;/p&gt;
&lt;p&gt;We’ll need only a subset of HTTP, though: a client wanting to negotiate a WebSocket connection just sends a request with &lt;code&gt;Connection: Upgrade&lt;/code&gt; and &lt;code&gt;Upgrade: websocket&lt;/code&gt; headers, and we need to reply in a predefined manner. And that’s all: we won’t need a full-blown web server to serve static content, etc. &amp;mdash; there are plenty of other tools that will do this for us.&lt;/p&gt;
&lt;figure&gt;&lt;br&gt;    &lt;img src=&quot;/static/rust-1/ws-headers.png&quot; class=&quot;fig&quot;&gt;&lt;br&gt;    &lt;figcaption&gt;WebSocket negotiation request headers.&lt;/figcaption&gt;&lt;br&gt;&lt;/figure&gt;

&lt;p&gt;But before we start to implement HTTP, we need to properly handle client connections, accepting them and subscribing to the socket events.&lt;/p&gt;
&lt;p&gt;Here’s the basic implementation:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use std::collections::HashMap;&amp;#10;&amp;#10;struct WebSocketServer &amp;#123;&amp;#10;    socket: TcpListener,&amp;#10;    clients: HashMap&amp;#60;Token, TcpStream&amp;#62;,&amp;#10;    token_counter: usize&amp;#10;&amp;#125;&amp;#10;&amp;#10;const SERVER_TOKEN: Token = Token(0);&amp;#10;&amp;#10;impl Handler for WebSocketServer &amp;#123;&amp;#10;    type Timeout = usize;&amp;#10;    type Message = ();&amp;#10;&amp;#10;    fn ready(&amp;#38;mut self, event_loop: &amp;#38;mut EventLoop&amp;#60;WebSocketServer&amp;#62;,&amp;#10;             token: Token, events: EventSet)&amp;#10;    &amp;#123;&amp;#10;        match token &amp;#123;&amp;#10;            SERVER_TOKEN =&amp;#62; &amp;#123;&amp;#10;                let client_socket = match self.socket.accept() &amp;#123;&amp;#10;                    Err(e) =&amp;#62; &amp;#123;&amp;#10;                        println!(&amp;#34;Accept error: &amp;#123;&amp;#125;&amp;#34;, e);&amp;#10;                        return;&amp;#10;                    &amp;#125;,&amp;#10;                    Ok(None) =&amp;#62; unreachable!(&amp;#34;Accept has returned &amp;#39;None&amp;#39;&amp;#34;),&amp;#10;                    Ok(Some((sock, addr))) =&amp;#62; sock&amp;#10;                &amp;#125;;&amp;#10;&amp;#10;                self.token_counter += 1;&amp;#10;                let new_token = Token(self.token_counter);&amp;#10;&amp;#10;                self.clients.insert(new_token, client_socket);&amp;#10;                event_loop.register(&amp;#38;self.clients[&amp;#38;new_token],&amp;#10;                                    new_token, EventSet::readable(),&amp;#10;                                    PollOpt::edge() | PollOpt::oneshot()).unwrap();&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;There is a lot more code now, so let’s look at it in more detail.&lt;/p&gt;
&lt;p&gt;First thing we need to do is to make the server struct &lt;code&gt;WebSocketServer&lt;/code&gt; stateful: it needs to contain the listening socket and store connected clients.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use std::collections::HashMap;&amp;#10;&amp;#10;struct WebSocketServer &amp;#123;&amp;#10;    socket: TcpListener,&amp;#10;    clients: HashMap&amp;#60;Token, TcpStream&amp;#62;,&amp;#10;    token_counter: usize&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We’re using &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.HashMap.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; from the standard collections library, &lt;code&gt;std::collections&lt;/code&gt;, to store client connections. As a key for the hash map we’re using a unique, non-overlapping &lt;em&gt;token&lt;/em&gt; that we should generate for an each connection to identify it.&lt;/p&gt;
&lt;p&gt;To provide reasonable uniqueness, we’ll just use a simple counter to generate new tokens sequentially. That’s why &lt;code&gt;token_counter&lt;/code&gt; variable is there.&lt;/p&gt;
&lt;p&gt;Next, the &lt;code&gt;Handler&lt;/code&gt; trait from &lt;code&gt;mio&lt;/code&gt; becomes useful again:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;impl Handler for WebSocketServer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we need to &lt;em&gt;override&lt;/em&gt; a callback function &lt;code&gt;ready&lt;/code&gt; within the trait implementation. Overriding means that the &lt;code&gt;Handler&lt;/code&gt; trait already contains a dummy &lt;code&gt;ready&lt;/code&gt; implementation (besides other default stubs for several callback functions as well). It does nothing useful, so we need to write our own version to handle events:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn ready(&amp;#38;mut self, event_loop: &amp;#38;mut EventLoop&amp;#60;WebSocketServer&amp;#62;,&amp;#10;         token: Token, events: EventSet)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This function gets called each time a socket becomes available for a read or write (depending on our subscription), and we’re provided with some useful info about the event through the call arguments: the event loop instance, the token linked to the event source (socket), and &lt;code&gt;events&lt;/code&gt;, a set of flags that provide details about the occurred event that could be either &lt;em&gt;readable&lt;/em&gt; or &lt;em&gt;writable&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The listening socket generate &lt;em&gt;readable&lt;/em&gt; events when a new client arrives into the acception queue and when we’re ready to connect with it. And that’s what we do next, but first we need to make sure that the event has sourced from the listening socket by doing &lt;em&gt;&lt;a href=&quot;https://doc.rust-lang.org/book/match.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pattern matching&lt;/a&gt;&lt;/em&gt; on a token:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match token &amp;#123;&amp;#10;    SERVER_TOKEN =&amp;#62; &amp;#123;&amp;#10;        ...&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;What does it mean? Well, the &lt;code&gt;match&lt;/code&gt; syntax resembles the standard &lt;em&gt;switch&lt;/em&gt; construct you can find in “traditional” imperative languages, but it has a lot more power to it. While in e.g. Java &lt;code&gt;switch&lt;/code&gt; can match only on numbers, strings, and enums, Rust’s &lt;code&gt;match&lt;/code&gt; works on ranges, multiple values, and structures as well, and more than that&amp;nbsp;&amp;mdash;&amp;nbsp;it can capture values from patterns, similar to capturing groups from the regular expressions.&lt;/p&gt;
&lt;p&gt;In this case we’re matching on a token to determine what socket has generated the event &amp;mdash; and, as you remember, &lt;code&gt;Token(0)&lt;/code&gt; corresponds to the listening socket on our server. In fact, we’ve made it a &lt;em&gt;constant&lt;/em&gt; to be more descriptive:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const SERVER_TOKEN: Token = Token(0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;So the above &lt;code&gt;match&lt;/code&gt; expression is equivalent to &lt;code&gt;match { Token(0) =&amp;gt; ... }&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that we know that we’re dealing with the server socket, we can proceed to accepting a client’s connection:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let client_socket = match self.socket.accept() &amp;#123;&amp;#10;    Err(e) =&amp;#62; &amp;#123;&amp;#10;        println!(&amp;#34;Accept error: &amp;#123;&amp;#125;&amp;#34;, e);&amp;#10;        return;&amp;#10;    &amp;#125;,&amp;#10;    Ok(None) =&amp;#62; unreachable!(),&amp;#10;    Ok(Some((sock, addr))) =&amp;#62; sock&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we’re doing the matching again, now over an outcome of the &lt;code&gt;accept()&lt;/code&gt; function call that returns the result typed as &lt;code&gt;Result&amp;lt;Option&amp;lt;TcpStream&amp;gt;&amp;gt;&lt;/code&gt;.  &lt;a href=&quot;https://doc.rust-lang.org/std/result/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is a special type fundamental to errors handling in Rust. It wraps around uncertain results such as errors, timeouts, etc., and we might decide what to do with them in each individual case.&lt;/p&gt;
&lt;p&gt;But we don’t have to&amp;nbsp;&amp;mdash;&amp;nbsp;remember that strange &lt;code&gt;unwrap()&lt;/code&gt; function that we were calling all the time? It has a standard implementation that terminates the program execution in case if the result is an error and returns it unwrapped if it’s normal. So basically by using &lt;code&gt;unwrap&lt;/code&gt; we’re telling that we’re interested in the immediate result only, and it’s OK to shut down the program if an error has happened.&lt;/p&gt;
&lt;p&gt;That’s an acceptable behavior in some places. However, in case of &lt;code&gt;accept()&lt;/code&gt; it’s not wise to use &lt;code&gt;unwrap()&lt;/code&gt; because it may accidentally shut down our entire service, effectively disconnecting all users, and we don’t want that. Instead, we’re just logging the fact of an error and continuing the execution:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Err(e) =&amp;#62; &amp;#123;&amp;#10;    println!(&amp;#34;Accept error: &amp;#123;&amp;#125;&amp;#34;, e);&amp;#10;    return;&amp;#10;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is another similar wrapper type that simply denotes that we either have some result or we don’t. If we have no result, the type has a value of &lt;code&gt;None&lt;/code&gt;, and the actual result is wrapped by &lt;code&gt;Some(value)&lt;/code&gt;. As you might suggest, the type itself can be compared to &lt;em&gt;null&lt;/em&gt; or &lt;em&gt;None&lt;/em&gt; values that can be found in many programming languages, but actually &lt;code&gt;Option&lt;/code&gt; is much safer&amp;nbsp;&amp;mdash;&amp;nbsp;you’ll never get the very common &lt;code&gt;NullReferenceException&lt;/code&gt; error unless you want to, as it works the same way as the &lt;code&gt;Result&lt;/code&gt; type: when you &lt;code&gt;unwrap()&lt;/code&gt; the &lt;code&gt;Option&lt;/code&gt; it shuts down the process if the result is &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, let’s unwrap the &lt;code&gt;accept()&lt;/code&gt; return value:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Ok(None) =&amp;#62; unreachable!(),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In this case, there’s simply no way for the result to be &lt;code&gt;None&lt;/code&gt;&amp;nbsp;&amp;mdash;&amp;nbsp;&lt;code&gt;accept()&lt;/code&gt; would return such value only if we’ll try to accept a connection on a non-listening socket. But as we’re pretty sure that we’re dealing with the server socket, it’s safe to crash the program using &lt;a href=&quot;https://doc.rust-lang.org/core/macro.unreachable!.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;unreachable!()&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;accept()&lt;/code&gt; has returned an unexpected value.&lt;/p&gt;
&lt;p&gt;So we’re just continuing to do the matching:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let client_socket = match self.socket.accept() &amp;#123;&amp;#10;    ...&amp;#10;    Ok(Some(sock)) =&amp;#62; sock&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;That’s the most interesting part. Besides matching the pattern, this line &lt;em&gt;captures&lt;/em&gt; the value that’s wrapped inside the &lt;code&gt;Result&amp;lt;Option&amp;lt;TcpStream&amp;gt;&amp;gt;&lt;/code&gt; type. This way we can effectively unwrap the value and return it as a result of an &lt;em&gt;expression&lt;/em&gt;. That means that &lt;code&gt;match&lt;/code&gt; operation acts as a kind of “function”&amp;nbsp;&amp;mdash;&amp;nbsp;we can return a matching result to a variable.&lt;/p&gt;
&lt;p&gt;That’s what we do here, binding the unwrapped value to the &lt;code&gt;client_socket&lt;/code&gt; variable. Next we’re going to store it in the clients hash table, while increasing the token counter:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let new_token = Token(self.token_counter);&amp;#10;self.clients.insert(new_token, client_socket);&amp;#10;self.token_counter += 1;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And finally we should subscribe to events from the newly accepted client’s socket by registering it within the event loop, in the very same fashion as with registration of the listening server socket, but providing another token &amp;amp; socket this time:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event_loop.register(&amp;#38;self.clients[&amp;#38;new_token],&amp;#10;                    new_token, EventSet::readable(),&amp;#10;                    PollOpt::edge() | PollOpt::oneshot()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;You might have noticed another difference in the provided arguments: there is a &lt;code&gt;PollOpt::oneshot()&lt;/code&gt; option along with the familiar &lt;code&gt;PollOpt::edge()&lt;/code&gt;. It tells that we want the triggered event to temporarily unregister from the event loop. It helps us make the code more simple and straightforward because in the other case we would have needed to track the current state of a particular socket&amp;nbsp;&amp;mdash;&amp;nbsp;i.e., maintain flags that we can write or read now, etc. Instead, we just simply reregister the event with a desired event set whenever it has been triggered.&lt;/p&gt;
&lt;p&gt;Oh, and besides that, now that we’ve got more detailed &lt;code&gt;WebSocketServer&lt;/code&gt; struct we must modify the event loop registration code in the main function a bit. Modifications mostly concern the struct initialization and are pretty simple:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let mut server = WebSocketServer &amp;#123;&amp;#10;    token_counter: 1,        // Starting the token counter from 1&amp;#10;    clients: HashMap::new(), // Creating an empty HashMap&amp;#10;    socket: server_socket    // Handling the ownership of the socket to the struct&amp;#10;&amp;#125;;&amp;#10;&amp;#10;event_loop.register(&amp;#38;server.socket,&amp;#10;                    SERVER_TOKEN,&amp;#10;                    EventSet::readable(),&amp;#10;                    PollOpt::edge()).unwrap();&amp;#10;&amp;#10;event_loop.run(&amp;#38;mut server).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;9-Parsing-HTTP&quot;&gt;&lt;a href=&quot;#9-Parsing-HTTP&quot; class=&quot;headerlink&quot; title=&quot;9 Parsing HTTP&quot;&gt;&lt;/a&gt;9 Parsing HTTP&lt;/h2&gt;&lt;p&gt;Afterwards, when we’ve accepted the client socket, by the protocol we should parse the incoming HTTP request to &lt;em&gt;upgrade&lt;/em&gt; the connection to WebSocket protocol.&lt;/p&gt;
&lt;p&gt;We won’t do it by hand, because it’s quite a boring task&amp;nbsp;&amp;mdash;&amp;nbsp;instead, we’ll add another dependency to the project, the &lt;code&gt;http-muncher&lt;/code&gt; crate that wraps the Node.js’s HTTP parser and adapts it for Rust. It allows to parse HTTP requests in a streaming mode that is very useful with TCP connections.&lt;/p&gt;
&lt;p&gt;Let’s add it to the &lt;code&gt;Cargo.toml&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[dependencies]
http-muncher = &amp;quot;0.2.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We won’t review the API and just proceed to parsing HTTP:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern crate http_muncher;&amp;#10;use http_muncher::&amp;#123;Parser, ParserHandler&amp;#125;;&amp;#10;&amp;#10;struct HttpParser;&amp;#10;impl ParserHandler for HttpParser &amp;#123; &amp;#125;&amp;#10;&amp;#10;struct WebSocketClient &amp;#123;&amp;#10;    socket: TcpStream,&amp;#10;    http_parser: Parser&amp;#60;HttpParser&amp;#62;&amp;#10;&amp;#125;&amp;#10;&amp;#10;impl WebSocketClient &amp;#123;&amp;#10;    fn read(&amp;#38;mut self) &amp;#123;&amp;#10;        loop &amp;#123;&amp;#10;            let mut buf = [0; 2048];&amp;#10;            match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;                Err(e) =&amp;#62; &amp;#123;&amp;#10;                    println!(&amp;#34;Error while reading socket: &amp;#123;:?&amp;#125;&amp;#34;, e);&amp;#10;                    return&amp;#10;                &amp;#125;,&amp;#10;                Ok(None) =&amp;#62;&amp;#10;                    // Socket buffer has got no more bytes.&amp;#10;                    break,&amp;#10;                Ok(Some(len)) =&amp;#62; &amp;#123;&amp;#10;                    self.http_parser.parse(&amp;#38;buf[0..len]);&amp;#10;                    if self.http_parser.is_upgrade() &amp;#123;&amp;#10;                        // ...&amp;#10;                        break;&amp;#10;                    &amp;#125;&amp;#10;                &amp;#125;&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    fn new(socket: TcpStream) -&amp;#62; WebSocketClient &amp;#123;&amp;#10;        WebSocketClient &amp;#123;&amp;#10;            socket: socket,&amp;#10;            http_parser: Parser::request(HttpParser)&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And we have some changes in the &lt;code&gt;WebSocketServer&lt;/code&gt;‘s &lt;code&gt;ready&lt;/code&gt; function:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match token &amp;#123;&amp;#10;    SERVER_TOKEN =&amp;#62; &amp;#123;&amp;#10;        ...&amp;#10;        self.clients.insert(new_token, WebSocketClient::new(client_socket));&amp;#10;        event_loop.register(&amp;#38;self.clients[&amp;#38;new_token].socket, new_token, EventSet::readable(),&amp;#10;                            PollOpt::edge() | PollOpt::oneshot()).unwrap();&amp;#10;        ...&amp;#10;    &amp;#125;,&amp;#10;    token =&amp;#62; &amp;#123;&amp;#10;        let mut client = self.clients.get_mut(&amp;#38;token).unwrap();&amp;#10;        client.read();&amp;#10;        event_loop.reregister(&amp;#38;client.socket, token, EventSet::readable(),&amp;#10;                              PollOpt::edge() | PollOpt::oneshot()).unwrap();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Now let’s review the new code line-by-line again.&lt;/p&gt;
&lt;p&gt;First, we import the HTTP parser library and define a handling struct for it:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern crate http_muncher;&amp;#10;use http_muncher::&amp;#123;Parser, ParserHandler&amp;#125;;&amp;#10;&amp;#10;struct HttpParser;&amp;#10;impl ParserHandler for HttpParser &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We need the &lt;code&gt;ParserHandler&lt;/code&gt; trait because it contains callback functions, the same way as the mio’s &lt;code&gt;Handler&lt;/code&gt; for the &lt;code&gt;WebSocketServer&lt;/code&gt;. These callbacks get called whenever the parser has some new info &amp;mdash; HTTP headers, the request body, etc. But as for now we need only to determine whether the request asks for a WebSocket protocol upgrade, and the parser struct itself has a handy function to check that, so we’ll stick to the stub callbacks implementation.&lt;/p&gt;
&lt;p&gt;There’s a detail: the HTTP parser is stateful, which means that we should create a new instance of it for each new client. Considering each client will contain its own parser state, we need to create a new struct to hold it:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct WebSocketClient &amp;#123;&amp;#10;    socket: TcpStream,&amp;#10;    http_parser: Parser&amp;#60;HttpParser&amp;#62;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This struct will effectively replace the &lt;code&gt;HashMap&amp;lt;Token, TcpStream&amp;gt;&lt;/code&gt; declaration with &lt;code&gt;HashMap&amp;lt;Token, WebSocketClient&amp;gt;&lt;/code&gt;, so we’ve added the client’s socket to the state as well.&lt;/p&gt;
&lt;p&gt;Also, we can use the same &lt;code&gt;WebSocketClient&lt;/code&gt; to hold code to manage data coming from a client. It’d be too inconvenient to put all the code in the &lt;code&gt;ready&lt;/code&gt; function &amp;mdash; it would quickly become messy and unreadable. So we’re just adding a separate handler that will manage each client:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;impl WebSocketClient &amp;#123;&amp;#10;    fn read(&amp;#38;mut self) &amp;#123;&amp;#10;        ...&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;It doesn’t need to take any arguments because we already have the required state in the containing struct itself.&lt;/p&gt;
&lt;p&gt;Now we can read the incoming data:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;loop &amp;#123;&amp;#10;    let mut buf = [0; 2048];&amp;#10;    match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;        ...&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here’s what’s going on: we’re starting an infinite loop, allocate some buffer space to hold the data, and trying to read it to the buffer.&lt;/p&gt;
&lt;p&gt;As the &lt;code&gt;try_read&lt;/code&gt; call may result in an error, we’re matching the &lt;code&gt;Result&lt;/code&gt; type to check for errors:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;    Err(e) =&amp;#62; &amp;#123;&amp;#10;        println!(&amp;#34;Error while reading socket: &amp;#123;:?&amp;#125;&amp;#34;, e);&amp;#10;        return&amp;#10;    &amp;#125;,&amp;#10;    ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Then we check if the read call has resulted in actual bytes:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;    ...&amp;#10;    Ok(None) =&amp;#62;&amp;#10;        // Socket buffer has got no more bytes.&amp;#10;        break,&amp;#10;    ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;It returns &lt;code&gt;Ok(None)&lt;/code&gt; in case if we’ve read all the data that the client has sent us. When that happens we go to wait for new events.&lt;/p&gt;
&lt;p&gt;And, finally, here’s the case when the &lt;code&gt;try_read&lt;/code&gt; has written bytes to the buffer:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;    ...&amp;#10;    Ok(Some(len)) =&amp;#62; &amp;#123;&amp;#10;        self.http_parser.parse(&amp;#38;buf[0..len]);&amp;#10;&amp;#10;        if self.http_parser.is_upgrade() &amp;#123;&amp;#10;            // ...&amp;#10;            break;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we’re providing a slice of the data to the parser, and then check if we have a request to “upgrade” the connection (which means that a user has provided the &lt;code&gt;Connection: Upgrade&lt;/code&gt; header).&lt;/p&gt;
&lt;p&gt;The final part is the &lt;code&gt;new&lt;/code&gt; method to conveniently create new &lt;code&gt;WebSocketClient&lt;/code&gt; instances:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn new(socket: TcpStream) -&amp;#62; WebSocketClient &amp;#123;&amp;#10;    WebSocketClient &amp;#123;&amp;#10;        socket: socket,&amp;#10;        http_parser: Parser::request(HttpParser)&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This is an &lt;em&gt;associated function&lt;/em&gt; which is analogous to static methods in the conventional OOP systems, and this particular function can be compared to a constructor. In this function we’re just creating a new instance of &lt;code&gt;WebSocketClient&lt;/code&gt; struct, but in fact we can perfectly do the job without the “constructor” function&amp;nbsp;&amp;mdash;&amp;nbsp;it’s just a shorthand, because without it the code would quickly become repetitive. After all, the &lt;dfn title=&quot;Don&#39;t Repeat Yourself&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Don&amp;#39;t_repeat_yourself&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DRY&lt;/a&gt;&lt;/dfn&gt; principle exists for a reason.&lt;/p&gt;
&lt;p&gt;There are few more details. First, notice that we don’t use an explicit &lt;code&gt;return&lt;/code&gt; statement to return the function result. Rust allows to return the result implicitly from a last expression of a function.&lt;/p&gt;
&lt;p&gt;Second, this line deserves more elaboration:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http_parser: Parser::request(HttpParser)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we’re creating a new instance of the &lt;code&gt;Parser&lt;/code&gt; by using an associated function &lt;code&gt;Parser::request&lt;/code&gt;, and we’re creating and passing a new instance of the previously defined &lt;code&gt;HttpParser&lt;/code&gt; struct as an argument.&lt;/p&gt;
&lt;p&gt;Let’s get back to the server code.&lt;/p&gt;
&lt;p&gt;To finish up, we’re making changes in the server socket handler:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match token &amp;#123;&amp;#10;    SERVER_TOKEN =&amp;#62; &amp;#123; ... &amp;#125;,&amp;#10;    token =&amp;#62; &amp;#123;&amp;#10;        let mut client = self.clients.get_mut(&amp;#38;token).unwrap();&amp;#10;        client.read();&amp;#10;        event_loop.reregister(&amp;#38;client.socket, token, EventSet::readable(),&amp;#10;                              PollOpt::edge() | PollOpt::oneshot()).unwrap();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We’ve added a new match expression that captures all tokens besides &lt;code&gt;SERVER_TOKEN&lt;/code&gt;, that is the client socket events.&lt;/p&gt;
&lt;p&gt;After we’ve got the token, we can borrow a mutable reference to the corresponding client struct instance from the clients hash map:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let mut client = self.clients.get_mut(&amp;#38;token).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And let’s call the &lt;code&gt;read&lt;/code&gt; function that we’ve written above:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;client.read();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In the end, we’ve got to reregister the client, because of &lt;code&gt;oneshot()&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event_loop.reregister(&amp;#38;client.socket, token, EventSet::readable(),&amp;#10;                      PollOpt::edge() | PollOpt::oneshot()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;As you can see, it doesn’t differ much from a client registration routine; in essence, we’re just calling &lt;code&gt;reregister&lt;/code&gt; instead of &lt;code&gt;register&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we know about a client’s intent to initiate a WebSocket connection, and we should think about how to reply to such requests.&lt;/p&gt;
&lt;h2 id=&quot;10-Handshake&quot;&gt;&lt;a href=&quot;#10-Handshake&quot; class=&quot;headerlink&quot; title=&quot;10 Handshake&quot;&gt;&lt;/a&gt;10 Handshake&lt;/h2&gt;&lt;p&gt;Basically, we could send back just these headers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Except there’s one more important thing&amp;nbsp;&amp;mdash;&amp;nbsp;the WebSocket protocol requires us to send a properly crafted &lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt; header as well. According to the &lt;a href=&quot;https://tools.ietf.org/html/rfc6455#section-4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC&lt;/a&gt;, there are certain rules: we need to get the &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header from a client, we need to append a long string to the key (&lt;code&gt;&amp;quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;quot;&lt;/code&gt;), then hash the resulting string with the SHA-1 algorithm, and in the end encode the result in base64.&lt;/p&gt;
&lt;p&gt;Rust doesn’t have SHA-1 and base64 in the standard library, but sure it does have them as separate libraries on &lt;em&gt;crates.io&lt;/em&gt;, so let’s include them to our  &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[dependencies]
...
rustc-serialize = &amp;quot;0.3.15&amp;quot;
sha1 = &amp;quot;0.1.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;rustc-serialize&lt;/code&gt; contains functions to encode binary data in base64, and &lt;code&gt;sha1&lt;/code&gt;, obviously, is for SHA-1.&lt;/p&gt;
&lt;p&gt;The actual function to encode the key is straightforward:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern crate sha1;&amp;#10;extern crate rustc_serialize;&amp;#10;&amp;#10;use rustc_serialize::base64::&amp;#123;ToBase64, STANDARD&amp;#125;;&amp;#10;&amp;#10;fn gen_key(key: &amp;#38;String) -&amp;#62; String &amp;#123;&amp;#10;    let mut m = sha1::Sha1::new();&amp;#10;    let mut buf = [0u8; 20];&amp;#10;&amp;#10;    m.update(key.as_bytes());&amp;#10;    m.update(&amp;#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&amp;#34;.as_bytes());&amp;#10;&amp;#10;    m.output(&amp;#38;mut buf);&amp;#10;&amp;#10;    return buf.to_base64(STANDARD);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We’re getting a reference to the key string as an argument for the &lt;code&gt;gen_key&lt;/code&gt; function, creating a new SHA-1 hash, appending the key to it, then appending the constant as required by the RFC, and return the base64-encoded string as a result.&lt;/p&gt;
&lt;p&gt;But to make use of this function we should capture the &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header first. To do that, let’s get back to the HTTP parser from the previous section. As you might remember, the &lt;code&gt;ParserHandler&lt;/code&gt; trait allows us to define callbacks that get called whenever we receive new headers. Now is the right time to use this feature, so let’s improve the parser struct implementation:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use std::cell::RefCell;&amp;#10;use std::rc::Rc;&amp;#10;&amp;#10;struct HttpParser &amp;#123;&amp;#10;    current_key: Option&amp;#60;String&amp;#62;,&amp;#10;    headers: Rc&amp;#60;RefCell&amp;#60;HashMap&amp;#60;String, String&amp;#62;&amp;#62;&amp;#62;&amp;#10;&amp;#125;&amp;#10;&amp;#10;impl ParserHandler for HttpParser &amp;#123;&amp;#10;    fn on_header_field(&amp;#38;mut self, s: &amp;#38;[u8]) -&amp;#62; bool &amp;#123;&amp;#10;        self.current_key = Some(std::str::from_utf8(s).unwrap().to_string());&amp;#10;        true&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    fn on_header_value(&amp;#38;mut self, s: &amp;#38;[u8]) -&amp;#62; bool &amp;#123;&amp;#10;        self.headers.borrow_mut()&amp;#10;            .insert(self.current_key.clone().unwrap(),&amp;#10;                    std::str::from_utf8(s).unwrap().to_string());&amp;#10;        true&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    fn on_headers_complete(&amp;#38;mut self) -&amp;#62; bool &amp;#123;&amp;#10;        false&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The piece of code is simple, but it introduces a new important concept: &lt;em&gt;shared ownership&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As you already know, in Rust we can have only one owner of a certain value, but sometimes we might need to share the ownership. For instance, in this case we need to scan a set of headers for a key while at the same time we’re collecting the headers in the parser handler. That means that we need to have 2 owners of the &lt;code&gt;headers&lt;/code&gt; variable: in &lt;code&gt;WebSocketClient&lt;/code&gt; and &lt;code&gt;ParserHandler&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/rust-1/ref-count.png&quot; class=&quot;float-right&quot;&gt;&lt;/p&gt;
&lt;p&gt;That’s where &lt;a href=&quot;https://doc.rust-lang.org/std/rc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; comes to help: it’s a value wrapper with a &lt;em&gt;reference counter&lt;/em&gt;, and in effect we’re moving the ownership of a value to the &lt;code&gt;Rc&lt;/code&gt; container, so the &lt;code&gt;Rc&lt;/code&gt; itself can be safely shared between many owners with the help of a special language trickery&amp;nbsp;&amp;mdash;&amp;nbsp;we just &lt;code&gt;clone()&lt;/code&gt; the &lt;code&gt;Rc&lt;/code&gt; value when we need to share it, and the wrapper safely manages memory for us.&lt;/p&gt;
&lt;p&gt;But here’s a caveat: the value &lt;code&gt;Rc&lt;/code&gt; contains is &lt;em&gt;immutable&lt;/em&gt;, i.e. because of the compiler constraints we can’t change it. In fact, it’s a natural consequence of Rust’s rules about mutability&amp;nbsp;&amp;mdash;&amp;nbsp;it allows to have as many borrows of a variable as you want, but you can change the value only within a single borrow.&lt;/p&gt;
&lt;p&gt;That’s not too convenient because we need to modify the list of headers as new data becomes available, and we’re pretty sure that we’re doing that only in one place, so no violations of Rust’s rules here&amp;nbsp;&amp;mdash;&amp;nbsp;yet the &lt;code&gt;Rc&lt;/code&gt; container wouldn’t allow us to modify its content.&lt;/p&gt;
&lt;p&gt;Fortunately, &lt;a href=&quot;https://doc.rust-lang.org/core/cell/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; fixes that&amp;nbsp;&amp;mdash;&amp;nbsp;this is another special container type that allows us to overcome this limit with a mechanism called &lt;em&gt;interior mutability&lt;/em&gt;. It simply means that we’re deferring all compiler checks to the &lt;em&gt;run time&lt;/em&gt; as opposed to checking borrows &lt;em&gt;statically&lt;/em&gt;, at &lt;em&gt;compile time&lt;/em&gt;. So all that we need to do is to double-wrap our value in a (quite monstrous looking) &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; container.&lt;/p&gt;
&lt;p&gt;Let’s consider this code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.headers.borrow_mut()&amp;#10;    .insert(self.current_key.clone().unwrap(),&amp;#10;            ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;It corresponds to &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrow with the only difference that all checks for constrained number of mutatable borrows are performed dynamically, so it’s up to us to make sure that we’re borrowing the value only once.&lt;/p&gt;
&lt;p&gt;Now, the actual owner of the &lt;code&gt;headers&lt;/code&gt; variable would be the &lt;code&gt;WebSocketClient&lt;/code&gt; struct, so let’s define the according properties there and write a new constructor function:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Import the RefCell and Rc crates from the standard library&amp;#10;use std::cell::RefCell;&amp;#10;use std::rc::Rc;&amp;#10;&amp;#10;...&amp;#10;&amp;#10;struct WebSocketClient &amp;#123;&amp;#10;    socket: TcpStream,&amp;#10;    http_parser: Parser&amp;#60;HttpParser&amp;#62;,&amp;#10;&amp;#10;    // Adding the headers declaration to the WebSocketClient struct&amp;#10;    headers: Rc&amp;#60;RefCell&amp;#60;HashMap&amp;#60;String, String&amp;#62;&amp;#62;&amp;#62;&amp;#10;&amp;#125;&amp;#10;&amp;#10;impl WebSocketClient &amp;#123;&amp;#10;    fn new(socket: TcpStream) -&amp;#62; WebSocketClient &amp;#123;&amp;#10;        let headers = Rc::new(RefCell::new(HashMap::new()));&amp;#10;&amp;#10;        WebSocketClient &amp;#123;&amp;#10;            socket: socket,&amp;#10;&amp;#10;            // We&amp;#39;re making a first clone of the `headers` variable&amp;#10;            // to read its contents:&amp;#10;            headers: headers.clone(),&amp;#10;&amp;#10;            http_parser: Parser::request(HttpParser &amp;#123;&amp;#10;                current_key: None,&amp;#10;&amp;#10;                // ... and the second clone to write new headers to it:&amp;#10;                headers: headers.clone()&amp;#10;            &amp;#125;)&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    ...&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Now &lt;code&gt;WebSocketClient&lt;/code&gt; can get access to parsed headers, and, consequently, we can read the header that interests us most, &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;. Considering we have the key from a client, the response routine boils down to just sending an HTTP string that we combine out of several parts.&lt;/p&gt;
&lt;p&gt;But as we can’t just send the data in the non-blocking environment, we need to switch the event loop to notify us when a client’s socket becomes available for a write.&lt;/p&gt;
&lt;p&gt;The solution is to switch our event set to &lt;code&gt;EventSet::writable()&lt;/code&gt; when we reregister the client’s socket.&lt;br&gt;Remember this line?&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event_loop.reregister(&amp;#38;client.socket, token, EventSet::readable(),&amp;#10;                      PollOpt::edge() | PollOpt::oneshot()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We just need to store the set of events that interests us with the other client’s state, so let’s rewrite it this way:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct WebSocketClient &amp;#123;&amp;#10;    socket: TcpStream,&amp;#10;    http_parser: Parser&amp;#60;HttpParser&amp;#62;,&amp;#10;    headers: Rc&amp;#60;RefCell&amp;#60;HashMap&amp;#60;String, String&amp;#62;&amp;#62;&amp;#62;,&amp;#10;&amp;#10;    // Adding a new `interest` property:&amp;#10;    interest: EventSet&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And, accordingly, let’s  modify the “reregister” procedure:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;event_loop.reregister(&amp;#38;client.socket, token,&amp;#10;                      client.interest, // Providing `interest` from the client&amp;#39;s struct&amp;#10;                      PollOpt::edge() | PollOpt::oneshot()).unwrap();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The only thing left to do is to change the client’s interest value at certain places.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;connection-states&quot;&gt;&lt;/a&gt;&lt;br&gt;To make it more straightforward, let’s formalize the process of tracking the connection states:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#[derive(PartialEq)]&amp;#10;enum ClientState &amp;#123;&amp;#10;    AwaitingHandshake,&amp;#10;    HandshakeResponse,&amp;#10;    Connected&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Here we define an &lt;em&gt;enumeration&lt;/em&gt; that will describe all possible states for a WebSocket client. These three are simple: first, &lt;code&gt;AwaitingHandshake&lt;/code&gt; means that we’re waiting for a handshake request in HTTP, &lt;code&gt;HandshakeResponse&lt;/code&gt; represents the state when we’re replying to the handshake (again, talking in HTTP), and, after that, &lt;code&gt;Connected&lt;/code&gt; indicates that we’ve started to communicate using the WebSocket protocol.&lt;/p&gt;
&lt;p&gt;Let’s add the client state variable to the client struct:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct WebSocketClient &amp;#123;&amp;#10;    socket: TcpStream,&amp;#10;    http_parser: Parser&amp;#60;HttpParser&amp;#62;,&amp;#10;    headers: Rc&amp;#60;RefCell&amp;#60;HashMap&amp;#60;String, String&amp;#62;&amp;#62;&amp;#62;,&amp;#10;    interest: EventSet,&amp;#10;&amp;#10;    // Add a client state:&amp;#10;    state: ClientState&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;And modify the constructor, providing the initial state and interest:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;impl WebSocketClient &amp;#123;&amp;#10;    fn new(socket: TcpStream) -&amp;#62; WebSocketClient &amp;#123;&amp;#10;        let headers = Rc::new(RefCell::new(HashMap::new()));&amp;#10;&amp;#10;        WebSocketClient &amp;#123;&amp;#10;            socket: socket,&amp;#10;            ...&amp;#10;            // Initial events that interest us&amp;#10;            interest: EventSet::readable(),&amp;#10;&amp;#10;            // Initial state&amp;#10;            state: ClientState::AwaitingHandshake&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Now we can actually change the state in the &lt;code&gt;read&lt;/code&gt; function. Remember these lines?&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;match self.socket.try_read(&amp;#38;mut buf) &amp;#123;&amp;#10;    ...&amp;#10;    Ok(Some(len)) =&amp;#62; &amp;#123;&amp;#10;        if self.http_parser.is_upgrade() &amp;#123;&amp;#10;            // ...&amp;#10;            break;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Finally we can replace the placeholder in the &lt;code&gt;is_upgrade()&lt;/code&gt; condition block with the state change code:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if self.http_parser.is_upgrade() &amp;#123;&amp;#10;    // Change the current state&amp;#10;    self.state = ClientState::HandshakeResponse;&amp;#10;&amp;#10;    // Change current interest to `Writable`&amp;#10;    self.interest.remove(EventSet::readable());&amp;#10;    self.interest.insert(EventSet::writable());&amp;#10;&amp;#10;    break;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;After we’ve changed our interest to &lt;code&gt;Writable&lt;/code&gt;, let’s add the required routines to reply to the handshake.&lt;/p&gt;
&lt;p&gt;We’ll modify the &lt;code&gt;ready&lt;/code&gt; function in our &lt;code&gt;WebSocketServer&lt;/code&gt; handler implementation. The writing handler itself is simple, and we only need to separate incoming events.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn ready(&amp;#38;mut self, event_loop: &amp;#38;mut EventLoop&amp;#60;WebSocketServer&amp;#62;,&amp;#10;         token: Token, events: EventSet) &amp;#123;&amp;#10;    // Are we dealing with the read event?&amp;#10;    if events.is_readable() &amp;#123;&amp;#10;        // Move all read handling code here&amp;#10;        match token &amp;#123;&amp;#10;            SERVER_TOKEN =&amp;#62; &amp;#123; ... &amp;#125;,&amp;#10;            ...&amp;#10;        &amp;#125;&amp;#10;        ...&amp;#10;    &amp;#125;&amp;#10;&amp;#10;    // Handle write events that are generated whenever&amp;#10;    // the socket becomes available for a write operation:&amp;#10;    if events.is_writable() &amp;#123;&amp;#10;        let mut client = self.clients.get_mut(&amp;#38;token).unwrap();&amp;#10;        client.write();&amp;#10;        event_loop.reregister(&amp;#38;client.socket, token, client.interest,&amp;#10;                              PollOpt::edge() | PollOpt::oneshot()).unwrap();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The remaining part is most simple&amp;nbsp;&amp;mdash;&amp;nbsp;we need to build and send the response string:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use std::fmt;&amp;#10;...&amp;#10;impl WebSocketClient &amp;#123;&amp;#10;    fn write(&amp;#38;mut self) &amp;#123;&amp;#10;        // Get the headers HashMap from the Rc&amp;#60;RefCell&amp;#60;...&amp;#62;&amp;#62; wrapper:&amp;#10;        let headers = self.headers.borrow();&amp;#10;&amp;#10;        // Find the header that interests us, and generate the key from its value:&amp;#10;        let response_key = gen_key(&amp;#38;headers.get(&amp;#34;Sec-WebSocket-Key&amp;#34;).unwrap());&amp;#10;&amp;#10;        // We&amp;#39;re using special function to format the string.&amp;#10;        // You can find analogies in many other languages, but in Rust it&amp;#39;s performed&amp;#10;        // at the compile time with the power of macros. We&amp;#39;ll discuss it in the next&amp;#10;        // part sometime.&amp;#10;        let response = fmt::format(format_args!(&amp;#34;HTTP/1.1 101 Switching Protocols\r\n\&amp;#10;                                                 Connection: Upgrade\r\n\&amp;#10;                                                 Sec-WebSocket-Accept: &amp;#123;&amp;#125;\r\n\&amp;#10;                                                 Upgrade: websocket\r\n\r\n&amp;#34;, response_key));&amp;#10;&amp;#10;        // Write the response to the socket:&amp;#10;        self.socket.try_write(response.as_bytes()).unwrap();&amp;#10;&amp;#10;        // Change the state:&amp;#10;        self.state = ClientState::Connected;&amp;#10;&amp;#10;        // And change the interest back to `readable()`:&amp;#10;        self.interest.remove(EventSet::writable());&amp;#10;        self.interest.insert(EventSet::readable());&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Let’s test it by connecting to the WebSocket server from a browser. Open the dev console in your favorite web browser (press &lt;code&gt;F12&lt;/code&gt;) and put this code there:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ws = new WebSocket(&amp;#39;ws://127.0.0.1:10000&amp;#39;);&amp;#10;&amp;#10;if (ws.readyState == WebSocket.OPEN) &amp;#123;&amp;#10;    console.log(&amp;#39;Connection is successful&amp;#39;);&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/static/rust-1/connection-success.png&quot; class=&quot;centered shadowed&quot;&gt;&lt;/p&gt;
&lt;p&gt;Looks like we’ve made it &amp;mdash; the connection is successfully established!&lt;/p&gt;
&lt;h2 id=&quot;Conclusion&quot;&gt;&lt;a href=&quot;#Conclusion&quot; class=&quot;headerlink&quot; title=&quot;Conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Whew. That was a whirlwind tour of language features and concepts, but that’s just a start&amp;nbsp;&amp;mdash;&amp;nbsp;be prepared for sequels to this article (of course, as lengthy and as boringly detailed as this one!). We have a lot more to cover: secure WebSockets, multithreaded event loop, benchmarking, and, of course, we still have to implement the communication protocol and write the actual application.&lt;/p&gt;
&lt;p&gt;But before we get to the app, we might do further refactoring, separating the library code from the application, likely following with eventual publication of the resulting library to &lt;em&gt;crates.io&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I suggest you to proceed to &lt;a href=&quot;/2015/11/09/rust-in-detail-2.html&quot;&gt;the next part&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All code for the part 1 is available on &lt;a href=&quot;https://github.com/nbaksalyar/rust-chat/tree/part-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Discussions on Reddit: &lt;a href=&quot;https://www.reddit.com/r/programming/comments/3of35e/rust_in_detail_writing_scalable_chat_service_from/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/rust/comments/3oczn3/rust_in_detail_writing_scalable_chat_service_from/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#2&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/rust/comments/3oczn3/rust_in_detail_writing_scalable_chat_service_from/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#3&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/3csjza/rust_in_detail_writing_scalable_chat_service_from/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#4&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Resources&quot;&gt;&lt;a href=&quot;#Resources&quot; class=&quot;headerlink&quot; title=&quot;Resources&quot;&gt;&lt;/a&gt;Resources&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://duartes.org/gustavo/blog/post/journey-to-the-stack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Journey to the Stack&lt;/a&gt; by Gustavo Duarte&amp;nbsp;&amp;mdash;&amp;nbsp;a series of articles that provides a good insight on the inner implementation of the stack and stack frames. It’ll help you to better understand the Rust memory management principles.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man7.org/tlpi/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Linux Programming Interface&lt;/a&gt; by Michael Kerrisk, 2010&amp;nbsp;&amp;mdash;&amp;nbsp;awesome book on the topic of using system APIs. Despite the title, applicable not only to Linux but to most *nix systems as well.&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;此篇文章翻译自&lt;a href=&quot;&quot;&gt;Rust-In-Details&lt;/a&gt;，已获得作者许可。转载或二次创作请保留本信息。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Part-1-实现Websocket协议&quot;&gt;&lt;a href=&quot;#Part-1-实现Websocket协议&quot; class=&quot;headerlink&quot; title=&quot;Part 1: 实现Websocket协议.&quot;&gt;&lt;/a&gt;Part 1: 实现Websocket协议.&lt;/h2&gt;&lt;p&gt;我们将会用一系列的文章，一步一步的来详细介绍如何编写一个可扩展、实时的聊天服务。&lt;/p&gt;
&lt;p&gt;为了更好的了解如何使用Rust来解决一些实际问题，我们将在本系列文章中，逐步的尝试使用Rust来编写一个可扩展的、实时的聊天服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Part 1&lt;/em&gt;包含了一些基本的项目配置，和一个简单的Websocket服务器框架。这些文章相当的深入浅出，并不需要读者有太多关于Rust的背景知识。当然，如果你熟悉POSIX API或者是C/C++，那么肯定会极大的有助于深入理解。最后，这是一篇相当长、而且面向底层的教程，我推荐你先准备上一杯好咖啡。&lt;/p&gt;
&lt;p&gt;好了，让我们开始吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="rust" scheme="http://markindev.github.io/tags/rust/"/>
    
      <category term="websocket" scheme="http://markindev.github.io/tags/websocket/"/>
    
  </entry>
  
</feed>
