<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Rust in Details Part 1：介绍、WebSocket实现 · Markin HOME</title><meta name="description" content="Rust in Details Part 1：介绍、WebSocket实现 - Jingkai Mao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/markindev" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Rust in Details Part 1：介绍、WebSocket实现</h1><div class="post-time">Feb 15, 2016</div><div class="post-content"><p><strong><em><a href="http://markindev.github.io/2016/02/15/Rust-in-Details-Part-1/">此篇</a>文章翻译自<a href="http://nbaksalyar.github.io/2015/07/10/writing-chat-in-rust.html" target="_blank" rel="external">Rust-In-Details</a>，已获得作者许可。转载或二次创作请保留本信息。</em></strong></p>
<p>为了更好的了解如何使用Rust来解决一些实际问题，我们将在本系列文章中，逐步的尝试使用Rust来编写一个可扩展的、实时的聊天服务。</p>
<p><em>Part 1</em>包含了一些基本的项目配置，和一个简单的Websocket服务器框架。这篇文章相当的深入浅出，并不需要读者有太多关于Rust的背景知识。当然，如果你熟悉POSIX API或者是C/C++，那么肯定会极大的有助于深入理解。最后，这是一篇相当长、而且面向底层的教程，我推荐你先准备上一杯好咖啡。</p>
<p>好了，让我们开始吧！</p>
<a id="more"></a>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#why-rust">为什么是Rust?</a></li>
<li><a href="#goals">目标</a></li>
<li><a href="#approaches-to-io">关于I/O的初步考量</a></li>
<li><a href="#event-loop">事件循环</a></li>
<li><a href="#starting-project">初始化工程</a></li>
<li><a href="#event-loop-in-rust">Rust中的事件循环</a></li>
<li><a href="#tcp-server">TCP服务器</a></li>
<li><a href="#accepting-connections">接受连接</a></li>
<li><a href="#parsing-http">解析HTTP</a></li>
<li><a href="#handshake">握手</a></li>
<li><a href="#conclusion">总结</a></li>
<li><a href="#resources">相关资源</a></li>
<li><a href="#notes">参考文献</a></li>
</ol>
<p><a name="why-rust"></a></p>
<h2 id="1-为什么是Rust"><a href="#1-为什么是Rust" class="headerlink" title="1 为什么是Rust?"></a>1 为什么是Rust?</h2><p>出于对系统编程的兴趣，我开始留意到Rust这门新生语言。底层开发总是带给我各式各样的挑战和满足，在这个领域有一个很常见的共识，那就是：由于众多不起眼的陷阱，正确的做对一件事情往往是非常困难的。</p>
<img src="/2016/02/15/Rust-in-Details-Part-1/rust-logo.png" alt="rust-logo" title="rust-logo">
<p>最常见的陷阱莫过于内存安全。它可能导致一系列诸如<a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="external">缓存溢出</a>、<a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="external">内存泄露</a>、<a href="http://stackoverflow.com/questions/21057393/what-does-double-free-mean" target="_blank" rel="external">Double Free</a>、<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="external">野指针</a>等让人头疼的问题。一个较为有名的例子便是OpenSSL中出现的<a href="http://heartbleed.com/" target="_blank" rel="external">Headerbleed</a> Bug，它就是由于不恰当的内存管理而导致的。出于同样的陷阱，也许还有更多更严重的Bug存在于这些软件之中也并不让人奇怪。</p>
<p>当然，在C++中我们有不少的工具和法则诸如智能指针[<a href="#ref-1">1</a>]、On-Stack Allocation[<a href="#ref-2">2</a>]等来试图解决问题。但遗憾的是，这些处理方式并不是建立在语言层面的。为了获得正确的行为，它假设所有的相关开发者，都能够正确理解并坚决的执行统一的设计。当代码库越来越庞大，参与人员越来越多，为了在庞大的Codebase中检查和避免错误，无论是对于开发人员的个人素质还是团队管理，都提出了不小的挑战。如果这些棘手而机械的问题可以被机器恰当的处理，那简直是再好不过了。</p>
<p>这就是垃圾回收（Garbage Collection）的产生的主要背景和原因。作为目前最热门的自动内存管理机制，几乎所有的现代语言及虚拟机都在某种程度上面使用了垃圾回收，它很好的解决了上面所说的内存问题。当然它也有自己的不足之处：在某些情况下，它过分的复杂了[<a href="#ref-3">3</a>]。它使用一个额外的运行时系统来标记、收集、清理未使用的内存[<a href="#ref-4">4</a>]，对于某些高性能要求的程序来说，往往需要付出相当的努力来优化GC导致的性能影响。</p>
<p>Rust，我们的主角，使用<em><a href="http://doc.rust-lang.org/stable/book/ownership.html" target="_blank" rel="external">ownership</a></em>和<em>borrowing</em>这两个概念来完成自动内存管理。它在确保内存安全的同时，可以避免额外的性能开销。</p>
<p>在Rust中，我们可以假设任意一个栈上的值都只存在一个<em>owner</em>。这意味着对某一特定的内存区域，同一时刻只存在一个可写的变量指向它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// 我们创建了一个具有元素1，2，3的向量A，并将它的所有权交由一个局部变量`foo`。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = foo;</span><br><span class="line"><span class="comment">// 现在我们将向量A的所有权交由bar。至此，`foo`将无法再次访问。</span></span><br></pre></td></tr></table></figure>
<p>由于只有一个有效的绑定存在。那么当绑定离开作用域（被<code>{</code>和<code>}</code>所包含的区域），所拥有的资源（内存，文件句柄，网络句柄等）便可以自动且安全的被释放掉。虽然听上去可能有些复杂，但不难发现，这个手段其实是非常常见且有效的方法。它有些类似于C++中的<code>std::auto_ptr&lt;T&gt;</code>组件，但却是通过编译时检查来完成，甚至没有<code>std::auto_ptr&lt;T&gt;</code>所带来的额外消耗。这也就是Rust的杀手特性，使它既拥有现代语言安全的内存，也保留了C/C++类语言的效率。</p>
<p><a name="goals"></a></p>
<h2 id="2-目标"><a href="#2-目标" class="headerlink" title="2 目标"></a>2 目标</h2><p>我喜欢通过做一些简单的、生产场景的小项目来学习一个新的语言，这样既有趣也方便在实际的上下文场景里去理解语言的特性。现在我选择编写一个类似于Chat Roulette的匿名文本聊天服务来学习Rust，这是由于聊天服务往往需要在处理多个连接的同时快速做出响应，它不仅能用上不少的Rust特性，还能被用做测试对比Rust的实际性能和内存印迹。</p>
<p>这系列文章的最终目标将是产生一个可执行文件以及一系列部署脚本，并将它们成功的部署运行在一些云服务器上面。</p>
<p>开始动手写代码之前，我们先稍微花上一些时间来分析在线服务中相当重要的一个议题：I/O操作。</p>
<p><a name="approaches-to-io"></a></p>
<h2 id="3-关于I-O的初步考量"><a href="#3-关于I-O的初步考量" class="headerlink" title="3 关于I/O的初步考量"></a>3 关于I/O的初步考量</h2><p>为了正常的运转，我们的服务需要通过网络Sockets发送和接受数据。这听上去也许是一个简单的任务，但为了更加有效率的处理输入和输出操作，我们往往需要根据实际情况采用不同的方式，这些方式最主要的区别在于是否阻塞。在默认情况下，当我们等待数据到达或传递时，会进入阻塞状态并阻止其余所有的CPU操作。</p>
<p>为了同时服务多个用户，避免某个I\O操作阻塞所有的用户请求，我们需要通过某种方式来独立他们。</p>
<p>最常见的解决方式是为每一个用户创建一个独立的进程，那么阻塞就只能对当前上下文的单个进程造成影响。这种方式简单易于编写，但是会带来额外的性能开销。除了每个进程都需要的额外栈空间[<a href="#ref-6">6</a>]外，每次发生进程<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="external"><em>上下文切换</em></a>时都会产生额外的性能开销。现代服务器CPU往往都有8~16个核心，当进程变多时，相当多的时钟都被OS Kernel所占用以保证正确的进行调度行为，更不要说切换中所导致的缓存失效、内存换页等问题。这些开销往往超乎你的想象，你很难通过这种方式编写一个类似于TechCrush、HackerNews或者是Reddit那样拥有超高并发量、超酷的应用。</p>
<p><a name="event-loop"></a></p>
<h2 id="4-事件循环"><a href="#4-事件循环" class="headerlink" title="4 事件循环"></a>4 事件循环</h2><img src="/2016/02/15/Rust-in-Details-Part-1/io-multiplex.png" alt="io-multiplex" title="io-multiplex">
<p>出于以上的原因，我们需要一些基于事件循环（Event Loop）的，更加高效的I/O多路复用API。在Linux[<a href="#ref-7">7</a>]下面可以使用<em>epoll</em>，在FreeBSD或者OS X[<a href="#ref-8">8</a>]下面可以使用<em>kqueue</em>。</p>
<p>这些API以一种类似的方法工作：在字节流首先从网络到达Sockets并准备好读写时，让他们通过某种方式通知我们，而不是阻塞在原地等待。事件循环以事件的形式通知API调用者，而不是周期性的检查数千个套接字。这个区别对于WebSocket应用程序尤其重要，因为大部分时间里，相当数量的客户端连接往往都是处于Idle状态。而利用异步I/O我们以极低的代价持有单个客户连接。</p>
<p>有趣的是，这些功能还能被使用在磁盘I/O之中。实际上，事件循环接受所有的文件句柄作为监听对象（*nix世界中的套接字本质上就是文件句柄）。</p>
<blockquote>
<p>Node.Js的EventLoop的Ruby的EventMachine都以类似的方式工作。同样的还有使用异步I/O的Nginx网络服务器[<a href="#ref-9">9</a>]。</p>
</blockquote>
<p><a name="starting-project"></a></p>
<h2 id="5-初始化工程"><a href="#5-初始化工程" class="headerlink" title="5 初始化工程"></a>5 初始化工程</h2><blockquote>
<p>我会假设你已经安装了Rust，假如你还没有完成这一步的话，请依据<a href="https://doc.rust-lang.org/book/installing-rust.html" target="_blank" rel="external">官方文档</a>进行操作.</p>
</blockquote>
<p>Rust有一套类似于Maven/Composer/npm/rake的发布工具<code>cargo</code>。它用于管理库依赖、处理构建过程、运行测试组件、简化工程创建等。让我们打开terminal，并执行下面的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new chat --bin</span><br></pre></td></tr></table></figure>
<p><code>--bin</code>是用来告诉Cargo创建一个可执行程序项目而不是一个库项目。作为这段操作的结果，我们将在当前目录下生成一个包含两个文件的chat文件夹：</p>
<ul>
<li>Cargo.toml</li>
<li>src/main.rs</li>
</ul>
<p><code>Cargo.toml</code>包含了项目信息和所有依赖项的描述（类似于JavaScript的<code>package.json</code>），而<code>src/main.rs</code>则是我们工程的入口源文件。</p>
<p>现在我们就可以通过命令<code>cargo run</code>来编译、执行程序了。当然，如果我们确实犯了错的话，它也会提示相关的错误信息。</p>
<p><a name="event-loop-in-rust"></a></p>
<h2 id="6-Rust中的事件循环"><a href="#6-Rust中的事件循环" class="headerlink" title="6 Rust中的事件循环"></a>6 Rust中的事件循环</h2><p>是时候用实践来检验理论了，让我们来创建一个简单的事件循环，它将会用于等待新的事件发生。幸运的是，我们并不需要手动处理所有的底层系统调用，有一个Rust库<a href="https://github.com/carllerche/mio" target="_blank" rel="external"><em>Metal IO</em></a>(简称<em>mio</em>)已经帮我们做了这些事情。</p>
<p>如果你还记得的话，我们使用Cargo来进行依赖库文件管理。它默认从Rust的包仓库<a href="https://crates.io" target="_blank" rel="external"><em>cargo.io</em></a>下载所需要的库文件。如果你需要使用某个最新的功能时，也可以通过配置直接从其他的Git仓库获取最新版本。</p>
<p>在完成这个系列文章的时候，cargo.io只存在<code>mio</code>的0.4版本。由于较新的v0.5版本引入了更多的功能和一些不兼容的API调整，所以我们选择配置<code>Cargo.toml</code>，并使用最新的版本。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[dependencies]</span></span><br><span class="line"><span class="setting">mio = <span class="value">&#123; git = <span class="string">"https://github.com/carllerche/mio"</span> &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>在添加完依赖后，我们需要在代码中显式的导入它们。所以让我们打开<code>main.rs</code>，并编辑：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> mio;</span><br><span class="line"><span class="keyword">use</span> mio::*;</span><br></pre></td></tr></table></figure>
<p><code>mio</code>的使用相当简单。首先，我们通过调用<code>EventLoop::new()</code>来创建一个事件循环，当然，仅仅有一个事件循环对象并没有太大的用处。我们需要定义一个实现了<code>Handler</code>接口的<a href="http://doc.rust-lang.org/stable/book/structs.html" target="_blank" rel="external"><em>structure</em></a>来驱动它。</p>
<p>尽管Rust并没有以”常见”的方式支持面向对象范式（OOP），但是结构体可以被视作经典OOP中的类，它们可以实现约定的接口<a href="http://doc.rust-lang.org/stable/book/traits.html" target="_blank" rel="external"><em>traits</em></a>来完成静态派发，或者是运行时派发。</p>
<p>这是我们定义一个struct的方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> WebSocketServer;</span><br></pre></td></tr></table></figure>
<p>下面为结构WebSocketServer实现<a href="https://carllerche.github.io/mio/mio/trait.Handler.html" target="_blank" rel="external">Handler</a>接口：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Handler <span class="keyword">for</span> WebSocketServer &#123;</span><br><span class="line">    <span class="comment">// Traits可以拥有默认的实现，所以Handler只需要我们提供具体的timeout和message类型；</span></span><br><span class="line">    <span class="comment">// 我们不会在这里涉及过多的细节，所以就让我们直接使用mio实例中的实现好了。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title">Timeout</span> = usize;</span><br><span class="line">    <span class="keyword">type</span> <span class="title">Message</span> = ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以启动事件循环了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> event_loop = EventLoop::new().unwrap();</span><br><span class="line">    <span class="comment">// 创建一个WebSocketServer实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handler = WebSocketServer;</span><br><span class="line">    <span class="comment">// ... 将它以可变引用的方式传入事件循环中</span></span><br><span class="line">    event_loop.run(&amp;<span class="keyword">mut</span> handler).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们终于第一次接触到了<em>borrows</em>，注意最后一行中<code>&amp;mut</code>的使用。它意味着我们临时的将所有权转移到了另外的绑定中，并且这个绑定是<em>可变的</em>。</p>
<img src="/2016/02/15/Rust-in-Details-Part-1/mut-borrow.png" alt="mut-borrow" title="mut-borrow">
<p>为了简单起见，我们可以使用下面两段伪代码来理解borrowing：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将value绑定至owner</span></span><br><span class="line"><span class="keyword">let</span> owner = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的作用域，并将所有权转移至borrow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> borrow = owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在borrow可以读写值了</span></span><br><span class="line">    borrow.mutate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有权返还给owner</span></span><br><span class="line">    owner = borrow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码差不多等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将value绑定至owner</span></span><br><span class="line"><span class="keyword">let</span> owner = value;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将value的所有权暂时可写的转借给borrow</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> borrow = &amp;<span class="keyword">mut</span> owner;</span><br><span class="line"></span><br><span class="line">    borrow.mutate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当borrow离开作用域时，将被转借的所有权自动归还给owner</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<em>每个作用域</em>，只能存在一个<em>mutable borrow</em>。实际上，当值的所有权被转借出去之后，在所有权被归还之前，原来持有该值的<code>owner</code>也不能读写该值。</p>
<p>除此之外，我们还有一种<em>immutable borrowing</em>的方式，它允许我们只读的访问值。与<code>&amp;mut borrow</code>不同，它允许我们对同一个变量持有多个只读的绑定，但它隐含了一些特殊规则，如果当前作用域内存在<em>immutable borrowing</em>，那么我们既不可以改变变量也不可以以<em>mutable</em>的形式将该变量borrow出去。</p>
<p>如果这个解释不够清晰，请原谅我并稍微耐下心来。由于borrows几乎遍布于Rust的代码的每一处，所以我们会有更多的机会在实际的代码中理解它。现在让我们回到工程本身。</p>
<p>通过运行<code>cargo run</code>，Cargo会自动下载所有需要的依赖，并编译、运行我们的工程。</p>
<p>似乎让人有些失望，运行的结果只是在terminal中一个闪烁的光标指针。但那意味我们已经成功的将事件循环运行起来了，现在让我们来给他添加一些实际的用处。</p>
<p><a name="tcp-server"></a></p>
<h2 id="7-TCP服务器"><a href="#7-TCP服务器" class="headerlink" title="7 TCP服务器"></a>7 TCP服务器</h2><p>为了创建一个TCP Server来接收WebSocket连接，我们需要使用空间<code>mio::tcp</code>中一个特殊的结构<code>TcpListener</code>。并且依据标准的流程创建一个服务器端Tcp Socket，绑定地址、监听、接收连接。下面是相关代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::SocketAddr;</span><br><span class="line"><span class="keyword">use</span> mio::tcp::*;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> address = <span class="string">"0.0.0.0:10000"</span>.parse::&lt;SocketAddr&gt;().unwrap();</span><br><span class="line"><span class="keyword">let</span> server_socket = TcpListener::bind(&amp;address).unwrap();</span><br><span class="line"></span><br><span class="line">event_loop.register(&amp;server_socket,</span><br><span class="line">                    Token(<span class="number">0</span>),</span><br><span class="line">                    EventSet::readable(),</span><br><span class="line">                    PollOpt::edge()).unwrap();</span><br></pre></td></tr></table></figure>
<p>现在让我们一行一行的分析上面的代码：</p>
<p>首先我们需要将TCP相关的空间和套接字结构导入到<code>main.rs</code>文件中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mio::tcp::*;</span><br><span class="line"><span class="keyword">use</span> std::net::SocketAddr;</span><br></pre></td></tr></table></figure>
<p>然后，我们把字符串<code>&quot;0.0.0.0:10000&quot;</code>解析为地址的结构体，并使用<code>TcpListener</code>来启动套接字监听：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="string">"0.0.0.0:10000"</span>.parse::&lt;SocketAddr&gt;().unwrap();</span><br><span class="line"><span class="keyword">let</span> server_socket = TcpListener::bind(&amp;address).unwrap();</span><br></pre></td></tr></table></figure>
<p>也许你会注意到每一行的最后我们都调用了<code>unwrap()</code>，请先暂时忽略它。现在我们需要把生成的套接字注册进事件循环中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">event_loop.register(&amp;server_socket,</span><br><span class="line">                        Token(<span class="number">0</span>),</span><br><span class="line">                        EventSet::readable(),</span><br><span class="line">                        PollOpt::edge()).unwrap();</span><br></pre></td></tr></table></figure>
<p><code>register</code>的参数稍微有些复杂：</p>
<ul>
<li><em>Token</em> 是我们传入套接字的一个全局唯一标示符。当我们收到新事件时，我们可以通过这个标示符来确定事件是从哪个套接字产生的。这里我们简单使用<code>Token(0)</code>作为监听套接字的标示符。</li>
<li><em>EventSet</em> 指明了我们所监听消息的类型：是收到新数据时触发事件，还是发送数据时触发事件，异或是两者都有？</li>
<li><em>PollOpt</em> 指明我触发的类型：<code>PollOpt::edge()</code>表示我们想要采用<em>边缘触发</em>而不是<em>水平触发</em>。</li>
</ul>
<blockquote>
<p>只要对应套接字中有数据可读写时，水平触发即产生新的事件，而边缘触发只在有新数据到达套接字时才会触发事件。你可以参考<a href="http://stackoverflow.com/questions/1966863/level-vs-edge-trigger-network-event-mechanisms" target="_blank" rel="external">StackOverflow</a>上面的这篇回答获得更多的细节。</p>
</blockquote>
<p>现在，假如我们通过<code>cargo run</code>运行当前的程序，并使用<code>lsof</code>命令，就可以看到如下的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -i :<span class="number">10000</span></span><br><span class="line">COMMAND   PID        USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">chat    <span class="number">58490</span> &lt;your user&gt;   <span class="number">6</span>u   IPv4 <span class="number">0</span>x333c1924c045ccc7      <span class="number">0</span>t0  TCP *:ndmp (LISTEN)</span><br></pre></td></tr></table></figure>
<p><a name="accepting-connections"></a></p>
<h2 id="8-接受连接"><a href="#8-接受连接" class="headerlink" title="8 接受连接"></a>8 接受连接</h2><p>所有的WebSocket连接都从一次<em>握手</em>协议开始，这个协议由一些特殊的HTTP请求、应答序列组成。因此，为了实现WebSocket，我们必须教会我们的程序学会理解HTTP/1.1。当然，我们可以只需要关注其中与建立连接相关的内容：</p>
<p>所有想要以WebSocket形式连接的客户端首先需要发送一个带有<code>Connection: Upgrade</code>头信息的HTTP，然后我们以特定的方式响应。</p>
<img src="/2016/02/15/Rust-in-Details-Part-1/ws-headers.png" alt="ws-headers" title="ws-headers">
<p>在开始实现HTTP协议之前，我们需要先接受客户端连接，并在事件循环中订阅它们的消息。</p>
<p>下面就是最基础的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> WebSocketServer &#123;</span><br><span class="line">    socket: TcpListener,</span><br><span class="line">    clients: HashMap&lt;Token, TcpStream&gt;,</span><br><span class="line">    token_counter: usize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SERVER_TOKEN: Token = Token(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Handler <span class="keyword">for</span> WebSocketServer &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title">Timeout</span> = usize;</span><br><span class="line">    <span class="keyword">type</span> <span class="title">Message</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;WebSocketServer&gt;,</span><br><span class="line">             token: Token, events: EventSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">match</span> token &#123;</span><br><span class="line">            SERVER_TOKEN =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> client_socket = <span class="keyword">match</span> <span class="keyword">self</span>.socket.accept() &#123;</span><br><span class="line">                    <span class="built_in">Err</span>(e) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">"Accept error: &#123;&#125;"</span>, e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="built_in">Ok</span>(<span class="built_in">None</span>) =&gt; <span class="built_in">unreachable!</span>(<span class="string">"Accept has returned 'None'"</span>),</span><br><span class="line">                    <span class="built_in">Ok</span>(<span class="built_in">Some</span>((sock, addr))) =&gt; sock</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.token_counter += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> new_token = Token(<span class="keyword">self</span>.token_counter);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.clients.insert(new_token, client_socket);</span><br><span class="line">                event_loop.register(&amp;<span class="keyword">self</span>.clients[&amp;new_token],</span><br><span class="line">                                    new_token, EventSet::readable(),</span><br><span class="line">                                    PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次给出了一大段代码，让我们来逐一分析其中的要点。</p>
<p>首先我们的服务结构<code>WebSocketServer</code>必然是有状态的：他需要记录当前的监听套接字和所有当前已经连接的客户端。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> WebSocketServer &#123;</span><br><span class="line">    socket: TcpListener,</span><br><span class="line">    clients: HashMap&lt;Token, TcpStream&gt;,</span><br><span class="line">    token_counter: usize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用标准库<code>std::collections</code>中的<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="external"><code>HashMap</code></a>来储存客户端连接。并为每一个客户端连接生成一个全局唯一的<em>token</em>作为它的标示符。</p>
<p>为了简单起见，我们使用了一个记录器<code>token_counter</code>，并升序的使用它为每个连接生成新的<em>token</em>。接下来，让我们再次深入<code>mio::Handler</code>接口：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Handler <span class="keyword">for</span> WebSocketServer</span><br></pre></td></tr></table></figure>
<p>这里我们需要<em>覆盖（override）</em>接口中的回调函数<code>ready</code>。覆盖意味者<code>Handler</code>接口已经为<code>ready</code>做了一个默认的实现（虽然并没有什么用处），现在我们将它替换为自己的版本。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;WebSocketServer&gt;,</span><br><span class="line">         token: Token, events: EventSet)</span><br></pre></td></tr></table></figure>
<p>每当有任何套接字可供访问，在事件循环中就会触发一个新的事件，并调用上面的函数。每次被调用，我们可以通过传入的参数来获得相关信息：触发事件的循环实例<code>event_loop</code>、触发事件套接字的<code>token</code>、以及一个位标志符号<code>events</code>，用于指明当前发生事件的套接字是否<em>readable</em>或<em>writable</em>。</p>
<p>每当一个新的客户端开始进入请求队列，并且准备好连接时，我们都会收到一个来自于监听套接字产生的<em>readable</em>事件。</p>
<p>现在，我们通过<a href="https://doc.rust-lang.org/book/match.html" target="_blank" rel="external">模式匹配</a>来确定<code>token</code>是否等价于<code>SERVER_TOKEN</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> token &#123;</span><br><span class="line">    SERVER_TOKEN =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们可以将关键字<code>match</code>简单的理解为Java语言中的<em>switch</em>，并辅以更强大的特性。比如在Java中，<code>switch</code>只能匹配数字、字符串以及枚举型。而在Rust中，<code>match</code>还可以匹配范围、多值、以及结构体等等，它甚至可以通过固定的模式，从匹配对象中提取特定元素，就像我们使用正则表达式一样。</p>
<p>在这里，我们仅仅使用它来匹配一个预定义好的，用于绑定在监听套接字上面的<code>Token(0)</code>。除此之外，我们使用关键字<code>const</code>来常量化这一绑定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_TOKEN: Token = Token(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>那么上面的<code>match</code>表达式可以等价于<code>match { Token(0) =&gt; ... }</code>。现在我们可以确定这个事件来自于监听套接字，并开始接受一个客户端连接了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> client_socket = <span class="keyword">match</span> <span class="keyword">self</span>.socket.accept() &#123;</span><br><span class="line">    <span class="built_in">Err</span>(e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Accept error: &#123;&#125;"</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">None</span>) =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">Some</span>((sock, addr))) =&gt; sock</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>accept()</code>函数会产生一个类型为<code>Result&lt;Option&lt;TcpStream&gt;&gt;</code>的返回值。<a href="https://doc.rust-lang.org/std/result/index.html" target="_blank" rel="external"><code>Result&lt;T&gt;</code></a>是一个Rust中相当常见的错误处理组件，它将不确定的结果，与诸如超时等错误一块封装起来，供调用者决定进一步的处理方式。这里我们再次对<code>accept()</code>的返回值使用匹配技术。</p>
<p>现在你还记得我们之前在<code>Result</code>返回值上面频繁使用的<code>unwrap()</code>函数吗？如果当前的<code>Result</code>当中包含任何错误，这个函数会直接中断程序的执行；反之则返回相对应的结果<code>T</code>。我们可以把它当做一个便捷的断言来使用。</p>
<p>当然，在某些情况下我们并不想让错误中断程序。比如现在，因为这样会中断所有已经连线的客户端。所以我们决定自行处理可能的错误，并将它简单的打印出来以供调试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Err</span>(e) =&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Accept error: &#123;&#125;"</span>, e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a href="https://doc.rust-lang.org/std/option/index.html" target="_blank" rel="external"><code>Option</code></a>是另一个类似于<code>Result</code>的封装类型，它用于指明返回值是否存在。如果存在的话，它实际的值将是一个包装的<code>Some(value)</code>，反之则是<code>None</code>。你也许会把<code>None</code>和其他语言中的<em>null</em>或者<em>nil</em>搞混，但他们无论从实现上还是使用上都相当的不同。除非你显式声明，否则使用<code>Option</code>永远不会让你的程序产生类似于<code>NullReferenceException</code>之类的错误。同样的，<code>unwrap()</code>函数也可以作用于<code>Option</code>之上，并在返回值为<code>None</code>时抛出异常中断程序执行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ok</span>(<span class="built_in">None</span>) =&gt; <span class="built_in">unreachable!</span>(),</span><br></pre></td></tr></table></figure>
<p>在我们的例子里，只有当我们尝试在一个未开始监听的套接字上面建立连接时，才会返回<code>None</code>。这是一个永远不应该产生的结果，所以我们直接使用断言<a href="https://doc.rust-lang.org/core/macro.unreachable!.html" target="_blank" rel="external"><code>unreachable!()</code></a>，当逻辑运行到此处便终止程序的运行。</p>
<p>让我们继续考查下一个匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> client_socket = <span class="keyword">match</span> <span class="keyword">self</span>.socket.accept() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">Some</span>(sock)) =&gt; sock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看上去更加复杂，也更加有意思。在做模式匹配的同时，这行代码使得<code>client_socket</code>获得了封装在<code>Result&lt;Option&lt;TcpStream&gt;&gt;</code>中的值<code>TcpStream</code>。这里很方便，并且高效率的取得到了封装值，并将其作为表达式的返回结果。这意味着我们可以将<code>match</code>操作想象成一个函数，它执行模式匹配并返回表达式结果。</p>
<p>现在我们已经将解封的值绑定至变量<code>client_socket</code>了。接下来，我们将它储存在Hash表中，并增加我们的<code>token_counter</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> new_token = Token(<span class="keyword">self</span>.token_counter);</span><br><span class="line"><span class="keyword">self</span>.clients.insert(new_token, client_socket);</span><br><span class="line"><span class="keyword">self</span>.token_counter += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>最后，我们用类似于注册监听套接字的方式，将这个新产生的客户端连接注册至事件循环内。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event_loop.register(&amp;<span class="keyword">self</span>.clients[&amp;new_token],</span><br><span class="line">                    new_token, EventSet::readable(),</span><br><span class="line">                    PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br></pre></td></tr></table></figure>
<p>你也许会注意到这里我们在<code>PollOpt::edge()</code>外，附带使用了一个特殊的标志<code>PollOpt::oneshot()</code>。它告诉事件循环，对于这个句柄，我们仅接受一次触发事件。当事件触发后，它需要将句柄从事件循环中自动移除。使用这个功能可以让我们避免记录某个句柄当前特定的状态，从而简化程序。每次收到触发事件后，我们将手动的把它重新注册回事件循环内。</p>
<p>好了，现在我们可以开始初始化核心结构<code>WebSocketServer</code>，并开始运行事件循环了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> server = WebSocketServer &#123;</span><br><span class="line">    token_counter: <span class="number">1</span>,        <span class="comment">// token_counter将从1开始计数</span></span><br><span class="line">    clients: HashMap::new(), <span class="comment">// 创建一个空的Hash表</span></span><br><span class="line">    socket: server_socket    <span class="comment">// 持有的服务器套接字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">event_loop.register(&amp;server.socket,</span><br><span class="line">                    SERVER_TOKEN,</span><br><span class="line">                    EventSet::readable(),</span><br><span class="line">                    PollOpt::edge()).unwrap();</span><br><span class="line"></span><br><span class="line">event_loop.run(&amp;<span class="keyword">mut</span> server).unwrap();</span><br></pre></td></tr></table></figure>
<p><a name="parsing-http"></a></p>
<h2 id="9-解析HTTP"><a href="#9-解析HTTP" class="headerlink" title="9 解析HTTP"></a>9 解析HTTP</h2><p>现在，我们可以接受客户端连接，通过解析它们的HTTP请求，将连接<em>upgrade</em>至WebSocket协议。</p>
<p>解析HTTP包含了许多无聊的细节，所以我们并不打算在这里过分的深入。我们会向项目里增加另外一个第三方库<code>http-muncher</code>来处理这些问题（它是通过包装Node.Js的HTTP解析器并导入至Rust来实现的）。它允许我们以流模式解析HTTP请求，这对于一个TCP连接来说相当的有用。</p>
<p>类似的，先在<code>Cargo.toml</code>文件中增加下面的内容：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[dependencies]</span></span><br><span class="line"><span class="setting">http-muncher = <span class="value"><span class="string">"0.2.0"</span></span></span></span><br></pre></td></tr></table></figure>
<p>让我们跳过关于API的细节，并直接使用它们来解析HTTP:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> http_muncher;</span><br><span class="line"><span class="keyword">use</span> http_muncher::&#123;Parser, ParserHandler&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> HttpParser;</span><br><span class="line"><span class="keyword">impl</span> ParserHandler <span class="keyword">for</span> HttpParser &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> WebSocketClient &#123;</span><br><span class="line">    socket: TcpStream,</span><br><span class="line">    http_parser: Parser&lt;HttpParser&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> WebSocketClient &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; <span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">                <span class="built_in">Err</span>(e) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">"Error while reading socket: &#123;:?&#125;"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="built_in">Ok</span>(<span class="built_in">None</span>) =&gt;</span><br><span class="line">                    <span class="comment">// 套接字缓存内没有更多的字节了。</span></span><br><span class="line">                    <span class="keyword">break</span>,</span><br><span class="line">                <span class="built_in">Ok</span>(<span class="built_in">Some</span>(len)) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">self</span>.http_parser.parse(&amp;buf[<span class="number">0</span>..len]);</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.http_parser.is_upgrade() &#123;</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(socket: TcpStream) -&gt; WebSocketClient &#123;</span><br><span class="line">        WebSocketClient &#123;</span><br><span class="line">            socket: socket,</span><br><span class="line">            http_parser: Parser::request(HttpParser)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并对<code>WebSocketServer</code>的<code>ready</code>回调函数些做出一些修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> token &#123;</span><br><span class="line">    SERVER_TOKEN =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">self</span>.clients.insert(new_token, WebSocketClient::new(client_socket));</span><br><span class="line">        event_loop.register(&amp;<span class="keyword">self</span>.clients[&amp;new_token].socket, new_token, EventSet::readable(),</span><br><span class="line">                            PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    token =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> client = <span class="keyword">self</span>.clients.get_mut(&amp;token).unwrap();</span><br><span class="line">        client.read();</span><br><span class="line">        event_loop.reregister(&amp;client.socket, token, EventSet::readable(),</span><br><span class="line">                              PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在让我再次逐一的分析上面的代码。</p>
<p>首先，我们将HTTP解析库导入至程序内，并声明一个专用的处理结构<code>HttpParser</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> http_muncher;</span><br><span class="line"><span class="keyword">use</span> http_muncher::&#123;Parser, ParserHandler&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> HttpParser;</span><br><span class="line"><span class="keyword">impl</span> ParserHandler <span class="keyword">for</span> HttpParser &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要实现接口<code>ParserHandler</code>，就如同我们为<code>WebSocketServer</code>实现<code>mio::Handler</code>接口一样。它声明了一些在解析HTTP过程中，可能会调用回调函数，比如解析到新的HTTP头信息，Request Body等。现在我们先将注意暂时集中在建立WebSocket连接，并使用<code>ParserHandler</code>的默认实现。</p>
<p>由于HTTP解析器是带状态的，这意味我们需要为每一个客户端建立一个记录这些状态的实例。那么我们就创建一个新的结构来描述它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> WebSocketClient &#123;</span><br><span class="line">    socket: TcpStream,</span><br><span class="line">    http_parser: Parser&lt;HttpParser&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们会使用这个结构将<code>HashMap&lt;Token, TcpStream&gt;</code>替换为<code>HashMap&lt;Token, WebSocketClient&gt;</code>。除了解析器本身的状态外，我们还会使用<code>WebSocketClient</code>来记录那些从客户端传递上来的数据。为了避免<code>ready()</code>函数过分的膨胀，变得不可维护。我们读写客户端数据的相关代码实现为新结构的成员函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> WebSocketClient &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于已经拥有了所需要的状态记录，所以它并不需要额外的参数。</p>
<p>现在我们可以开始读取数据了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; <span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的事情就简单了：我们分配一些内存空间用于保存原始数据，并开启一个循环，依次的从中读取。由于<code>try_read</code>可能会产生一些错误，所以我们首先要通过匹配它的返回值<code>Result</code>来处理他们：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">    <span class="built_in">Err</span>(e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Error while reading socket: &#123;:?&#125;"</span>, e);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如当前缓存中所有的数据都已经被读取完毕，它会返回一个<code>Ok(None)</code>作为结果。在这种情形下，我们中断这个读取循环，并等待下一个事件消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">None</span>) =&gt;</span><br><span class="line">        <span class="keyword">break</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们处理那些<code>try_read</code>返回的有效数据结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">Some</span>(len)) =&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.http_parser.parse(&amp;buf[<span class="number">0</span>..len]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.http_parser.is_upgrade() &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将数据的一个<em>slice</em>提供给了解析器供其分析，并检查这个请求是否提供了一个<code>Connection: Upgrade</code>头信息来<em>upgrade</em>当前的连接。</p>
<p>除了<code>read</code>之外，我们编写了一个<code>new</code>方法用于生成一个新的<code>WebSocketClient</code>实例。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(socket: TcpStream) -&gt; WebSocketClient &#123;</span><br><span class="line">    WebSocketClient &#123;</span><br><span class="line">        socket: socket,</span><br><span class="line">        http_parser: Parser::request(HttpParser)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有使用<code>&amp;self</code>，<code>&amp;mut self</code>，<code>self</code>作为首参数的函数被称为<em>关联函数（associated function）</em>，它有些类似于常见OOP语言中的静态函数。我们使用new作为这个关联函数的名称，并把它用作构造器，这是一个Rust中较为常见的写法和命名约定。我们当然可以不使用它，而手工声明每一个<code>WebSocketClient</code>结构，但是遵循<a href="https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself" target="_blank" rel="external">DRY</a>并不是一个坏主意。</p>
<p>你可能会注意到：我们并没有显式的使用<code>return</code>关键字来返回函数的结果，Rust允许我们隐式的将最后一行表达式执行结果作为函数的返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_parser: Parser::request(HttpParser)</span><br></pre></td></tr></table></figure>
<p>我们在这里通过调用关联函数<code>Parser::request</code>，并将之前创建的类型HttpParser实例化作为参数，用于创建一个新的<code>Parser</code>新实例，</p>
<p>现在让我们返回服务器部分的代码，需要作出一些相应的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match token &#123;&#10;    SERVER_TOKEN =&#62; &#123; ... &#125;,&#10;    token =&#62; &#123;&#10;        let mut client = self.clients.get_mut(&#38;token).unwrap();&#10;        client.read();&#10;        event_loop.reregister(&#38;client.socket, token, EventSet::readable(),&#10;                              PollOpt::edge() | PollOpt::oneshot()).unwrap();&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里增加了一个新的匹配表达式来获得所有非<code>SERVER_TOKEN</code>的<em>token</em>，标示当前的事件是由某个客户端套接字触发的。</p>
<p>在获得<em>token</em>之后，我们就可以使用它从Hash表中以<em>mutable reference</em>的形式获得相对应的客户端实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut client = self.clients.get_mut(&#38;token).unwrap();</span><br></pre></td></tr></table></figure>
<p>现在让我们执行对应的<code>read()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.read();</span><br></pre></td></tr></table></figure>
<p>最后，由于我们使用了<code>oneshot()</code>标示，我们需要重新将当前客户端的套接字注册进事件循环当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_loop.reregister(&#38;client.socket, token, EventSet::readable(),&#10;                      PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用<code>reregister</code>函数而不是<code>register</code>函数，其参数保持与之前一致。</p>
<p>现在，我们可以正确的识别一个客户端是否请求建立WebSocket连接。我们需要开始思考如何响应这些请求。</p>
<p><a name="handshake"></a></p>
<h2 id="10-握手"><a href="#10-握手" class="headerlink" title="10 握手"></a>10 握手</h2><p>最基本的，一个WebSocket握手请求的响应信息内需要附带如下信息：</p>
<blockquote>
<p>HTTP/1.1 101 Switching Protocols<br>Connection: Upgrade<br>Upgrade: websocket</p>
</blockquote>
<p>除此之外，WebSocket协议要求我们发送一个<code>Sec-WebSocket-Accept</code>头字段。根据<a href="https://tools.ietf.org/html/rfc6455#section-4" target="_blank" rel="external">RFC6455</a>中的描述，我们可以这样生成字段值：首先将从客户端请求处获得的<code>Sec-WebSocket-Key</code>头字段，拼接上特殊字符串(“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”)；然后把它们做SHA-1哈希，以Base64格式编码即生成了最终结果。</p>
<p>Rust标准库内并没有携带SHA-1以及Base64算法，所以我们将选用<em>crates.io</em>中的一些第三方库来完成这个功能。所以，让我们打开<code>Cargo.toml</code>并编辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">...</span><br><span class="line">rustc-serialize = "0.3.15"</span><br><span class="line">sha1 = "0.1.1"</span><br></pre></td></tr></table></figure>
<p>如同他们名字所暗示的那样：<code>rustc-serialize</code>包含Base64编码解码相关代码，<code>sha1</code>包含SHA-1哈希相关代码。具体的使用方式如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> sha1;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rustc_serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rustc_serialize::base64::&#123;ToBase64, STANDARD&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gen_key</span></span>(key: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> m = sha1::Sha1::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0u8</span>; <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    m.update(key.as_bytes());</span><br><span class="line">    m.update(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>.as_bytes());</span><br><span class="line"></span><br><span class="line">    m.output(&amp;<span class="keyword">mut</span> buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf.to_base64(STANDARD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以一个指向字符串的引用作为函数<code>gen_key</code>的参数。在这段函数中，先是生成SHA-1哈希对象，并将字符串作为Key值传递给它，然后根据RFC规范，在将特定的常量数据添加进去，最后返回一个以Base64编码的字符串。</p>
<p>为了使用这段函数，我们首先需要获得请求中的<code>Sec-WebSocket-Key</code>字段，我们将在HTTP解析器回调接口中完成这一功能。也许你还记得，<code>ParserHandler</code>接口允许我们定义一些回调函数，供解析器在获得特定内容时触发调用。现在让我们来实现这些回调函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> HttpParser &#123;</span><br><span class="line">    current_key: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> ParserHandler <span class="keyword">for</span> HttpParser &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">on_header_field</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.current_key = <span class="built_in">Some</span>(std::str::from_utf8(s).unwrap().to_string());</span><br><span class="line">        <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">on_header_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;[<span class="keyword">u8</span>]) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.headers.borrow_mut()</span><br><span class="line">            .insert(<span class="keyword">self</span>.current_key.clone().unwrap(),</span><br><span class="line">                    std::str::from_utf8(s).unwrap().to_string());</span><br><span class="line">        <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">on_headers_complete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码并不复杂，但它引入了一个新的概念<em>共享所有权</em>（shared ownership）。</p>
<p>正如同你所知道的，在Rust中，任一栈上面的值对象都只存在一个所有者。而对于堆上面的对象，我们可以有更多的选择。比如在现在我们既需要在解析器回调函数中写入数据，也需要在其他地方读取写入的值。这意味着我们需要在<code>WebSocketClient</code>和<code>ParserHandler</code>之间共享<code>handlers</code>所指向的数据。</p>
<img src="/2016/02/15/Rust-in-Details-Part-1/ref-count.png" alt="ref-count" title="ref-count">
<p>我们可以采用<a href="https://doc.rust-lang.org/std/rc/" target="_blank" rel="external"><code>Rc</code></a>来解决这一问题。它是一个基于<em>引用计数</em>的包装结构，提供了针对堆上不可变对象的所有权共享服务。你可以把它看做C/C++中的<code>std::shared_ptr</code>。当我们需要额外的所有权时，我们只需要针对<code>Rc</code>对象调用<code>clone()</code>即可，它所指向的数据会在最后一个所有者离开作用域后被自动清理掉。</p>
<p>但是这里还有一个问题：那就是<code>Rc</code>所包含的对象是<em>不可变</em>的，由于编译器的限制，我们将无法修改它。这与Rust关于可变性的原则是相符的，要么允许任意多个不可变的borrow，要么只能存在一个可写的borrow。</p>
<p>标准库中的<code>Cell</code>和<a href="https://doc.rust-lang.org/core/cell/index.html" target="_blank" rel="external"><code>RefCell</code></a>通过<em>内部可见性</em>的概念被构造来解决这一使用场景。它标示着我们将相关的<em>静态编译时</em>检查延后至<em>运行时</em>来进行。在这里我们将会构造一个双层包装的容器<code>Rc&lt;RefCell&lt;...&gt;&gt;</code>。</p>
<p>让我们继续看下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.headers.borrow_mut()</span><br><span class="line">    .insert(<span class="keyword">self</span>.current_key.clone().unwrap(),</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>这里的用法与<code>&amp;mut</code>引用类似，但唯一需要注意到的是，关于可写转借的检查被移动至了运行期，需要由我们确定当前仅有一个可写转借存在。在这里<code>headers</code>变量的实际拥有者变为了<code>WebSocketClient</code>实例。让我们根据这一需求调整构造函数中的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入标准库中的RefCell与Rc模块</span></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> WebSocketClient &#123;</span><br><span class="line">    socket: TcpStream,</span><br><span class="line">    http_parser: Parser&lt;HttpParser&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于储存解析过程中所获得的头描述信息</span></span><br><span class="line">    headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> WebSocketClient &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(socket: TcpStream) -&gt; WebSocketClient &#123;</span><br><span class="line">        <span class="keyword">let</span> headers = Rc::new(RefCell::new(HashMap::new()));</span><br><span class="line"></span><br><span class="line">        WebSocketClient &#123;</span><br><span class="line">            socket: socket,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们在这里产生对`headers`指向对象的所有权</span></span><br><span class="line">            headers: headers.clone(),</span><br><span class="line"></span><br><span class="line">            http_parser: Parser::request(HttpParser &#123;</span><br><span class="line">                current_key: <span class="built_in">None</span>,</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ... 然后在这里产生另一个对`headers`指向对象的所有权</span></span><br><span class="line">                headers: headers.clone()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>WebSocketClient</code>可以访问被解析的HTTP头了，当然也包括我们最关心的那一个：<code>Sec-WebSocket-Key</code>。</p>
<p>但是我们不能直接在一个非阻塞的环境下发送数据，我们需要设置事件循环，当客户端套接字可写的时候通知我们。我们可以在注册这一套接字的时候通过将<code>EventSet</code>标记为<code>EventSet::writable()</code>来实现这个目的。</p>
<p>还记得这一段代码吗？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event_loop.reregister(&amp;client.socket, token, EventSet::readable(),</span><br><span class="line">                      PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br></pre></td></tr></table></figure>
<p>显而易见的，我们需要将当前感兴趣的客户端事件状态保存下来，所以对<code>WebSocketClient</code>做一些小修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> WebSocketClient &#123;</span><br><span class="line">    socket: TcpStream,</span><br><span class="line">    http_parser: Parser&lt;HttpParser&gt;,</span><br><span class="line">    headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前感兴趣的事件类型</span></span><br><span class="line">    interest: EventSet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event_loop.reregister(&amp;client.socket, token,</span><br><span class="line">                      client.interest, <span class="comment">// 在这里将事件类型传入</span></span><br><span class="line">                      PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br></pre></td></tr></table></figure>
<p>现在唯一需要解决的问题便是事件类型的状态在什么事件，以什么样的结果发生改变。为了简化讨论，让我们将连接的过程确定为几个固定的步骤：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#[derive(PartialEq)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title">ClientState</span> &#123;</span><br><span class="line">    AwaitingHandshake,</span><br><span class="line">    HandshakeResponse,</span><br><span class="line">    Connected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个<em>枚举型</em>用于描述WebSocket客户端所有可能的状态。<code>AwaitingHandshake</code>状态表示着我们正在等待HTTP中的一个握手请求；<code>HandshakeResponse</code>表示我们已经回应了客户端的握手请求；<code>Connected</code>表示我们成功的创立了基于WebSocket协议的连接。</p>
<p>让我们把这个状态保存至客户端的结构中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> WebSocketClient &#123;</span><br><span class="line">    socket: TcpStream,</span><br><span class="line">    http_parser: Parser&lt;HttpParser&gt;,</span><br><span class="line">    headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&gt;&gt;,</span><br><span class="line">    interest: EventSet,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存客户端当前的连接状态</span></span><br><span class="line">    state: ClientState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后针对性的修改构建器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> WebSocketClient &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(socket: TcpStream) -&gt; WebSocketClient &#123;</span><br><span class="line">        <span class="keyword">let</span> headers = Rc::new(RefCell::new(HashMap::new()));</span><br><span class="line"></span><br><span class="line">        WebSocketClient &#123;</span><br><span class="line">            socket: socket,</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 初始化监听事件为：是否可读</span></span><br><span class="line">            interest: EventSet::readable(),</span><br><span class="line">            <span class="comment">// 初始化当前状态为：等待握手</span></span><br><span class="line">            state: ClientState::AwaitingHandshake</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们在<code>read</code>函数中修改客户端状态：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="keyword">self</span>.socket.try_read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Ok</span>(<span class="built_in">Some</span>(len)) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.http_parser.is_upgrade() &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们在<code>is_upgrade()</code>所确定的作用域中增加关于状态变化的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.http_parser.is_upgrade() &#123;</span><br><span class="line">    <span class="comment">// 将当前的连接状态设置为：响应握手</span></span><br><span class="line">    <span class="keyword">self</span>.state = ClientState::HandshakeResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的监听事件切换为：是否可写</span></span><br><span class="line">    <span class="keyword">self</span>.interest.remove(EventSet::readable());</span><br><span class="line">    <span class="keyword">self</span>.interest.insert(EventSet::writable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们将监听事件的类型切换为是否可写后，再让我们添加响应握手请求的部分。</p>
<p>我们将会修改<code>WebSocketServer</code>结构关于<code>ready</code>函数的实现，可写事件处理本身并不复杂，我们只需要将它和可读事件处理分割开来。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ready</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;WebSocketServer&gt;,</span><br><span class="line">         token: Token, events: EventSet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理可读事件</span></span><br><span class="line">    <span class="keyword">if</span> events.is_readable() &#123;</span><br><span class="line">        <span class="comment">// 将所有处理读事件的代码移到这里</span></span><br><span class="line">        <span class="keyword">match</span> token &#123;</span><br><span class="line">            SERVER_TOKEN =&gt; &#123; ... &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理所有的可写事件</span></span><br><span class="line">    <span class="keyword">if</span> events.is_writable() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> client = <span class="keyword">self</span>.clients.get_mut(&amp;token).unwrap();</span><br><span class="line">        client.write();</span><br><span class="line">        event_loop.reregister(&amp;client.socket, token, client.interest,</span><br><span class="line">                              PollOpt::edge() | PollOpt::oneshot()).unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的事情就更加简单了，我们将构造好的返回值传递给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt;&#10;...&#10;impl WebSocketClient &#123;&#10;    fn write(&#38;mut self) &#123;&#10;        // &#20174;Rc&#60;RefCell&#60;...&#62;&#62;&#20013;&#33719;&#24471;Hash&#34920;&#10;        let headers = self.headers.borrow();&#10;&#10;        // &#26681;&#25454;`Sec-WebSocket-Key`&#20013;&#30340;&#20540;&#29983;&#25104;&#21709;&#24212;&#20869;&#23481;&#10;        let response_key = gen_key(&#38;headers.get(&#34;Sec-WebSocket-Key&#34;).unwrap());&#10;&#10;        // &#25105;&#20204;&#20351;&#29992;&#20102;&#19968;&#20010;&#29305;&#27530;&#30340;&#20989;&#25968;&#26469;&#26500;&#36896;&#23383;&#31526;&#20018;&#65292;&#20110;&#20854;&#20182;&#20989;&#25968;&#19981;&#21516;&#30340;&#26159;&#12290;&#30001;&#20110;Rust&#24378;&#22823;&#10;        // &#30340;&#23439;&#33021;&#21147;&#65292;&#36825;&#37324;&#30340;&#26500;&#36896;&#23436;&#25104;&#20110;&#32534;&#35793;&#26102;&#32780;&#19981;&#26159;&#36816;&#34892;&#26102;&#12290;&#10;        let response = fmt::format(format_args!(&#34;HTTP/1.1 101 Switching Protocols\r\n\&#10;                                                 Connection: Upgrade\r\n\&#10;                                                 Sec-WebSocket-Accept: &#123;&#125;\r\n\&#10;                                                 Upgrade: websocket\r\n\r\n&#34;, response_key));&#10;&#10;        // &#23558;Response&#20889;&#20837;&#22871;&#25509;&#23383;&#10;        self.socket.try_write(response.as_bytes()).unwrap();&#10;&#10;        // &#25913;&#21464;&#24403;&#21069;&#30340;&#29366;&#24577;&#20026;&#65306;&#36830;&#25509;&#25104;&#21151;&#10;        self.state = ClientState::Connected;&#10;&#10;        // &#23558;&#24403;&#21069;&#30340;&#30417;&#21548;&#20107;&#20214;&#20999;&#25442;&#20026;&#65306;&#26159;&#21542;&#21487;&#35835;&#10;        self.interest.remove(EventSet::writable());&#10;        self.interest.insert(EventSet::readable());&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们使用浏览器来测试连接这个WebSocket服务器。在你的浏览器中打开开发者窗口（一般是按<code>F12</code>），并输入如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:10000'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ws.readyState == WebSocket.OPEN) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection is successful'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2016/02/15/Rust-in-Details-Part-1/connection-success.png" alt="connection-success" title="connection-success">
<p>看起来连接已经成功的创建了！</p>
<p><a name="conclusion"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真是令人难以相信，我们接触了如此多的语言概念和功能，但这仅仅只是后续文章的开始（是的，依然如同本章一样冗长和底层）。为了实现我们的聊天程序，还需要对安全、多进程、性能测试、通讯协议等议题进行讨论。在这之前，我们应该先好好的重构一下现有代码，将通用部分从程序中抽离出来作为一个库，也许还能将它提交至<em>crates.io</em>。</p>
<p>相关的代码参见：<a href="https://github.com/nbaksalyar/rust-chat/tree/part-1" target="_blank" rel="external">GitHub</a><br>相关的Reddit讨论参见：<a href="https://www.reddit.com/r/programming/comments/3of35e/rust_in_detail_writing_scalable_chat_service_from/" target="_blank" rel="external">#1</a>, <a href="https://www.reddit.com/r/rust/comments/3oczn3/rust_in_detail_writing_scalable_chat_service_from/" target="_blank" rel="external">#2</a>, <a href="https://www.reddit.com/r/rust/comments/3oczn3/rust_in_detail_writing_scalable_chat_service_from/" target="_blank" rel="external">#3</a>, <a href="https://www.reddit.com/r/programming/comments/3csjza/rust_in_detail_writing_scalable_chat_service_from/" target="_blank" rel="external">#4</a>.</p>
<p><a name="resources"></a></p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><p><a href="http://duartes.org/gustavo/blog/post/journey-to-the-stack/" target="_blank" rel="external">Journey to the Stack</a> by Gustavo Duarte; a series of articles that provides a good insight on the inner implementation of the stack and stack frames. It’ll help you to better understand the Rust memory management principles.</p>
</li>
<li><p><a href="http://man7.org/tlpi/" target="_blank" rel="external">The Linux Programming Interface</a> by Michael Kerrisk, 2010&nbsp;&mdash;&nbsp;awesome book on the topic of using system APIs. Despite the title, applicable not only to Linux but to most *nix systems as well.</p>
</li>
</ul>
<p><a name="notes"></a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a name="ref-1">[1]</a> Interestingly enough, Rust actually brings <a href="https://en.wikipedia.org/wiki/Smart_pointer" target="_blank" rel="external">smart pointers</a> to the language level: borrowing is based around ideas akin to C++’s <code>unique_ptr</code> and <code>shared_ptr</code>.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-2">[2]</a> For instance, <a href="http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf" target="_blank" rel="external">NASA JPL C Programming Coding Standard</a> and <dfn title="Motor Industry Software Reliability Association">MISRA</dfn> C standard explicitly forbid dynamic memory allocation with <code>malloc()</code> and implies local variables allocation on the stack and usage of pre-allocated memory instead.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-3">[3]</a> While basic garbage collection algos are relatively easy to implement, more smart approaches like concurrent GCs are very non-trivial. In fact, a sign of complexity is that Go getting concurrent GC only in version 1.5 &mdash; almost 3 years since the 1.0 release.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-4">[4]</a> Strictly speaking, many implementations of <code>malloc()</code> and <code>free()</code> functions suffer from a similar overhead as well becase of <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing" target="_blank" rel="external">fragmentation</a>). More on that topic can be found in “<a href="http://www.design-reuse.com/articles/25090/dynamic-memory-allocation-fragmentation-c.html" target="_blank" rel="external">Dynamic Memory Allocation and Fragmentation in C and C++</a>“ by Colin Walls.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-5">[5]</a> “Graydon Hoare [&hellip;] started working on a new programming language called Rust in 2006.” &mdash; <a href="http://www.infoq.com/news/2012/08/Interview-Rust" target="_blank" rel="external">InfoQ: “Interview On Rust”</a>&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-6">[6]</a> According to <code>pthread_create(3)</code> manual page, it defaults to 2 MB on 32-bit Linux systems.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-7">[7]</a> For comparison of <em>epoll</em> to other system APIs, refer to “<a href="https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf" target="_blank" rel="external">Comparing and Evaluating epoll, select, and poll Event Mechanisms</a>“ by Louay Gammo, Tim Brecht, et&nbsp;al., University of Waterloo, 2004.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-8">[8]</a> “<a href="http://people.freebsd.org/~jlemon/papers/kqueue.pdf" target="_blank" rel="external">Kqueue: A generic and scalable event notification facility</a>“ by Jonathan Lemon, FreeBSD Project.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-9">[9]</a> “<a href="http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="external">Inside Nginx: How We Designed For Performance Scale</a>“ by Owen Garrett.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
<p><a name="ref-10">[10]</a> <a href="http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html" target="_blank" rel="external">General description</a> on LinuxJournal.com. If you’re interested in more details, read “<a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html" target="_blank" rel="external">How TCP backlog works in Linux</a>“ by Andreas Veithen.&nbsp;<a href="javascript:history.back(" target="_blank" rel="external">&uarr;</a>)</p>
</div></article></div></section><footer><div class="paginator"></div><div id="disqus_thread"></div><script>var disqus_shortname = 'markindev';
var disqus_identifier = '2016/02/15/Rust-in-Details-Part-1/';
var disqus_title = 'Rust in Details Part 1：介绍、WebSocket实现';
var disqus_url = 'http://markindev.github.io/2016/02/15/Rust-in-Details-Part-1/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//markindev.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://markindev.github.io">Jingkai Mao</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>